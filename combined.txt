
// WebShieldApp/Model/ContentBlockerState.swift
import SafariServices
import SwiftUI

actor ContentBlockerState: ObservableObject {
    private let identifier = "me.arjuna.WebShield.ContentBlocker"

    func reloadContentBlocker() async {
        do {
            try await SFContentBlockerManager.reloadContentBlocker(
                withIdentifier: identifier)
            print("Content blocker reloaded successfully")
        } catch {
            await handleReloadError(error)
        }
    }

    private func handleReloadError(_ error: Error) async {
        let nsError = error as NSError
        print("ERROR: Failed to reload content blocker")
        print("Error description: \(nsError.localizedDescription)")
        print("Error domain: \(nsError.domain)")
        print("Error code: \(nsError.code)")

        if let underlyingError = nsError.userInfo[NSUnderlyingErrorKey]
            as? NSError
        {
            print("Underlying error: \(underlyingError)")
        }

        print("User Info:")
        for (key, value) in nsError.userInfo {
            print("  \(key): \(value)")
        }

        if nsError.domain == "SFErrorDomain" {
            await handleSFErrorDomain(code: nsError.code)
        }
    }

    private func handleSFErrorDomain(code: Int) async {
        switch code {
        case 1:
            print(
                "SFErrorDomain error 1: Content Blocker not found or not owned by you."
            )
            print("Bundle Identifier: \(self.identifier)")
            print(
                "Please check JSON validity and file size (max 2MB, 50,000 rules)."
            )
        case 2:
            print("SFErrorDomain error 2: NSExtensionItem missing attachment.")
        case 3:
            print(
                "SFErrorDomain error 3: Error loading content blocker extension."
            )
        default:
            print("Unknown SFErrorDomain error code: \(code)")
        }
    }
}

// WebShieldApp/Model/Extension/ColorExtension.swift
import Foundation
import SwiftUI

extension Color {

    #if os(macOS)
        static let background = Color(NSColor.windowBackgroundColor)
        static let secondaryBackground = Color(NSColor.underPageBackgroundColor)
        static let tertiaryBackground = Color(NSColor.controlBackgroundColor)
    #else
        static let background = Color(UIColor.systemBackground)
        static let secondaryBackground = Color(
            UIColor.secondarySystemBackground)
        static let tertiaryBackground = Color(UIColor.tertiarySystemBackground)
    #endif
}

// WebShieldApp/Model/Extension/EditMode.swift
// Documentation comments are copied from the official documentation for iOS.

import SwiftUI

#if os(macOS)

    /// Reimplemenation of [EditMode](https://developer.apple.com/documentation/swiftui/editmode) for macOS.
    public enum EditMode {

        /// The user can edit the view content.
        case active

        /// The user can’t edit the view content.
        case inactive

        /// The view is in a temporary edit mode.
        case transient
    }

    extension EditMode: Equatable {}
    extension EditMode: Hashable {}

    extension EditMode {

        /// Indicates whether a view is being edited.
        ///
        /// This property returns `true` if the mode is something other than inactive.
        public var isEditing: Bool {
            self != .inactive
        }
    }

    private struct EditModeEnvironmentKey: @preconcurrency EnvironmentKey {
        @MainActor static var defaultValue: Binding<EditMode>?
    }

    extension EnvironmentValues {

        /// An indication of whether the user can edit the contents of a view associated with this environment.
        public var editMode: Binding<EditMode>? {
            get {
                self[EditModeEnvironmentKey.self]
            }
            set {
                self[EditModeEnvironmentKey.self] = newValue
            }
        }
    }

#endif

// Below extension also don't exist on iOS, so keep them outside of the compiler directive block.

extension EditMode {

    /// Toggles the edit mode between `.inactive` and `.active`.
    public mutating func toggle() {
        switch self {
        case .inactive: self = .active
        case .active: self = .inactive
        case .transient: break
        #if os(iOS)
            @unknown default: break
        #endif
        }
    }
}

extension Optional where Wrapped == Binding<EditMode> {

    /// Convenience property so call sites can use a clean `editMode.isEditing` instead of the
    /// ugly boilerplate `editMode?.wrappedValue.isEditing == true`.
    public var isEditing: Bool {
        self?.wrappedValue.isEditing == true
    }
}

// WebShieldApp/Model/Extension/ModelContextExtension.swift
import Foundation
import SwiftData

extension ModelContext {
    func deleteAll<T: PersistentModel>(_ type: T.Type) throws {
        let fetchDescriptor = FetchDescriptor<T>()
        let results = try fetch(fetchDescriptor)
        for object in results {
            delete(object)
        }
    }
}

// WebShieldApp/Model/Extension/StringExtension.swift
// Helper extension for String truncation
extension String {
    func truncated(to length: Int, trailing: String = "...") -> String {
        return self.count > length
            ? String(self.prefix(length)) + trailing : self
    }
}

// WebShieldApp/Model/Extension/UserDefaultsExtension.swift
import Foundation

extension UserDefaults {
    static func exists(key: String) -> Bool {
        return UserDefaults.standard.object(forKey: key) != nil
    }
}

// WebShieldApp/Model/FilterList/FilterList.swift
import Foundation
import SwiftData

// MARK: - Model
@Model
final class FilterList {
    @Attribute(.unique) var id: String
    var name: String = "No Name"
    var version: String = "No Version"
    var desc: String = "No Description"
    var categoryString: String = FilterListCategory.custom.rawValue
    var isEnabled: Bool = false
    var order: Int = 0
    var urlString: String?
    var homepageURL: String?
    var standardRuleCount: Int = 0
    var advancedRuleCount: Int = 0
    var lastUpdated: Date = Date()
    var informationURL: String?

    // Initializer
    init(
        name: String = "No Name",
        version: String = "No Version",
        desc: String = "No Description",
        category: FilterListCategory,
        isEnabled: Bool = false,
        order: Int = 0,
        homepageURL: String? = nil,
        informationURL: String? = nil
    ) {
        self.id = UUID().uuidString
        self.name = name
        self.version = version
        self.desc = desc
        self.categoryString = category.rawValue
        self.isEnabled = isEnabled
        self.order = order
        self.urlString = nil
        self.homepageURL = homepageURL
        self.informationURL = informationURL
    }
}

// MARK: - Identifiable & Hashable
extension FilterList: Identifiable, Hashable {
    static func == (lhs: FilterList, rhs: FilterList) -> Bool {
        lhs.id == rhs.id
    }

    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
}

// MARK: - Computed Properties
extension FilterList {
    var category: FilterListCategory? {
        FilterListCategory(rawValue: categoryString)
    }

    var totalRuleCount: Int {
        standardRuleCount + advancedRuleCount
    }
}

// WebShieldApp/Model/FilterList/FilterListCategory.swift
import SwiftUI

// Add Codable conformance
enum FilterListCategory: String, CaseIterable, Identifiable, Codable {
    case all = "All"
    case ads = "Ads"
    case privacy = "Privacy"
    case security = "Security"
    case multipurpose = "Multipurpose"
    case cookies = "Cookies"
    case social = "Social"
    case annoyances = "Annoyances"
    case regional = "Regional"
    case experimental = "Experimental"
    case custom = "Custom"

    var id: String { self.rawValue }

    var systemImage: String {
        switch self {
        case .all: return "square.grid.2x2"
        case .ads: return "megaphone"
        case .privacy: return "hand.raised"
        case .security: return "lock"
        case .multipurpose: return "square.stack.3d.down.right"
        case .cookies: return "circle.dotted.circle"
        case .social: return "bubble.left.and.bubble.right"
        case .annoyances: return "exclamationmark.triangle"
        case .regional: return "globe"
        case .experimental: return "flask"
        case .custom: return "slider.horizontal.3"
        }
    }
}


// WebShieldApp/Model/FilterList/FilterListData.swift
import Foundation

struct FilterListData {
    let id: String
    let name: String
    let urlString: String
    let category: FilterListCategory
    let isSelected: Bool
    let description: String
    let homepageURL: String?
    let informationURL: String?

    init(
        id: String,
        name: String,
        urlString: String,
        category: FilterListCategory,
        isSelected: Bool,
        description: String,
        homepageURL: String? = nil,
        informationURL: String? = nil
    ) {
        self.id = id
        self.name = name
        self.urlString = urlString
        self.category = category
        self.isSelected = isSelected
        self.description = description
        self.homepageURL = homepageURL
        self.informationURL = informationURL
    }
}

// WebShieldApp/Model/FilterList/FilterListError.swift
import Foundation

enum FilterListError: LocalizedError {
    case invalidData
    case invalidFormat
    case downloadFailed
    case parsingFailed

    var errorDescription: String? {
        switch self {
        case .invalidData:
            return "Invalid filter list data"
        case .invalidFormat:
            return "Invalid filter list format"
        case .downloadFailed:
            return "Failed to download filter list"
        case .parsingFailed:
            return "Failed to parse filter list"
        }
    }
}

// WebShieldApp/Model/FilterList/FilterListProcessor.swift
import ContentBlockerConverter
import Foundation
import SwiftData

struct ProcessedConversionResult {
    let totalConvertedCount: Int
    let convertedCount: Int
    let errorsCount: Int
    let overLimit: Bool
    let converted: String?
    let advancedBlocking: [ContentBlockerRule]?
    let message: String?
}

struct Rule: Encodable, Decodable {
    let trigger: Trigger
    let action: Action

    struct Trigger: Encodable, Decodable {
        let urlFilter: String
        let urlFilterIsCaseSensitive: Bool?
        let resourceType: [String]?
        let ifDomain: [String]?
        let unlessDomain: [String]?
        let ifTopURL: [String]?
        let unlessTopURL: [String]?
        let loadType: [String]?

        // CodingKeys to match JSON keys if different from property names
        enum CodingKeys: String, CodingKey {
            case urlFilter = "url-filter"
            case urlFilterIsCaseSensitive = "url-filter-is-case-sensitive"
            case resourceType = "resource-type"
            case ifDomain = "if-domain"
            case unlessDomain = "unless-domain"
            case ifTopURL = "if-top-url"
            case unlessTopURL = "unless-top-url"
            case loadType = "load-type"
        }
    }

    struct Action: Encodable, Decodable {
        let type: String
        let selector: String?
        let subject: String?

        // CodingKeys if needed
        enum CodingKeys: String, CodingKey {
            case type, selector, subject
        }
    }
}

struct ContentBlockerRule: Codable {
    let trigger: Trigger
    let action: Action

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(trigger, forKey: .trigger)
        try container.encode(action, forKey: .action)
    }

    enum CodingKeys: String, CodingKey {
        case trigger, action
    }
}

struct Trigger: Codable {
    let urlFilter: String
    let ifDomain: [String]?
    let unlessDomain: [String]?

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(urlFilter, forKey: .urlFilter)
        try container.encodeIfPresent(ifDomain, forKey: .ifDomain)
        try container.encodeIfPresent(unlessDomain, forKey: .unlessDomain)
    }

    enum CodingKeys: String, CodingKey {
        case urlFilter = "url-filter"
        case ifDomain = "if-domain"
        case unlessDomain = "unless-domain"
    }
}

struct Action: Codable {
    let type: String
    let script: String?
    let css: String?
    let scriptlet: String?
    let scriptletParam: String?

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(type, forKey: .type)
        try container.encodeIfPresent(script, forKey: .script)
        try container.encodeIfPresent(css, forKey: .css)
        try container.encodeIfPresent(scriptlet, forKey: .scriptlet)
        try container.encodeIfPresent(scriptletParam, forKey: .scriptletParam)
    }

    enum CodingKeys: String, CodingKey {
        case type, script, css, scriptlet, scriptletParam
    }
}

extension ContentBlockerRule {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        trigger = try container.decode(Trigger.self, forKey: .trigger)
        action = try container.decode(Action.self, forKey: .action)
    }
}

extension Trigger {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        urlFilter = try container.decode(String.self, forKey: .urlFilter)
        ifDomain = try container.decodeIfPresent(
            [String].self, forKey: .ifDomain)
        unlessDomain = try container.decodeIfPresent(
            [String].self, forKey: .unlessDomain)
    }
}

extension Action {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        type = try container.decode(String.self, forKey: .type)
        script = try container.decodeIfPresent(String.self, forKey: .script)
        css = try container.decodeIfPresent(String.self, forKey: .css)
        scriptlet = try container.decodeIfPresent(
            String.self, forKey: .scriptlet)
        scriptletParam = try container.decodeIfPresent(
            String.self, forKey: .scriptletParam)
    }
}

@MainActor
struct FilterListProcessor {
    let urlSession: URLSession

    init(urlSession: URLSession = .shared) {
        self.urlSession = urlSession
    }

    func downloadFilterList(from url: URL) async throws -> Data {
        let (data, _) = try await urlSession.data(from: url)
        return data
    }

    func downloadAndParse(
        from url: URL, id: String, name: String, existingHomepage: String? = nil
    ) async throws -> (ProcessedConversionResult, String, String?) {
        LogsView.logProcessingStep("Starting download", for: name)

        let data = try await downloadData(from: url, for: name)

        LogsView.logProcessingStep("Starting parsing", for: name)
        let rules = try await parseRules(data, for: name)
        LogsView.logProcessingStep(
            "Successfully parsed \(rules.count) rules", for: "Parser")

        // Log a sample of the rules for debugging
        if let firstRule = rules.first {
            LogsView.logProcessingStep(
                "Sample rule: \(firstRule)", for: name)
        }

        // Extract metadata but preserve existing homepage if present
        let metadata = try extractMetadata(from: data)
        let homepage = existingHomepage ?? metadata.homepage
        if let homepage = homepage {
            LogsView.logProcessingStep(
                "Using homepage: \(homepage)", for: name)
        }

        LogsView.logProcessingStep(
            "Starting conversion of \(rules.count) rules", for: name)

        // Update here to use ProcessedConversionResult
        let result = try await convertRulesToAdGuardFormat(rules, for: name)

        logConversionStatistics(from: result, for: name)

        return (result, metadata.version, metadata.homepage)
    }

    // Helper functions for better readability and error handling

    private func downloadData(from url: URL, for name: String) async throws
        -> Data
    {
        do {
            let (data, _) = try await urlSession.data(from: url)
            LogsView.logProcessingStep("Download completed", for: name)
            return data
        } catch {
            LogsView.logProcessingStep(
                "Download failed: \(error.localizedDescription)", for: name)
            throw error
        }
    }

    private func parseRules(_ data: Data, for name: String) async throws
        -> [String]
    {
        guard let content = String(data: data, encoding: .utf8) else {
            LogsView.logProcessingStep(
                "Failed to decode data as UTF-8", for: "Parser")
            throw FilterListError.invalidData
        }

        let lines = content.components(separatedBy: .newlines)
            .map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }

        let validRules = lines.filter { !$0.isEmpty && !$0.hasPrefix("!") }

        guard !validRules.isEmpty else {
            LogsView.logProcessingStep(
                "No valid rules found after parsing", for: "Parser")
            throw FilterListError.parsingFailed
        }

        return validRules
    }

    func convertToAdGuardFormat(_ rules: [String]) async throws
        -> ProcessedConversionResult
    {
        LogsView.logProcessingStep(
            "Converting rules with ContentBlockerConverter", for: "Converter")
        let converter = ContentBlockerConverter()
        let result = converter.convertArray(
            rules: rules,
            safariVersion: .safari16_4,
            optimize: true,
            advancedBlocking: true,
            advancedBlockingFormat: .json
        )

        if result.errorsCount > 0 {
            LogsView.logProcessingStep(
                "Conversion had \(result.errorsCount) errors", for: "Converter")
        }

        // Decode advancedBlocking into an array of ContentBlockerRule
        var advancedRules: [ContentBlockerRule] = []
        if let advancedBlockingString = result.advancedBlocking,
            let data = advancedBlockingString.data(using: .utf8)
        {
            do {
                let rules = try JSONDecoder().decode(
                    [ContentBlockerRule].self, from: data)
                advancedRules = rules
            } catch {
                LogsView.logProcessingStep(
                    "Failed to decode advancedBlocking JSON: \(error.localizedDescription)",
                    for: "Converter"
                )
            }
        }

        // Create a ProcessedConversionResult
        let processedResult = ProcessedConversionResult(
            totalConvertedCount: result.totalConvertedCount,
            convertedCount: result.convertedCount,
            errorsCount: result.errorsCount,
            overLimit: result.overLimit,
            converted: result.converted,
            advancedBlocking: advancedRules,
            message: result.message
        )

        return processedResult
    }

    private func logConversionStatistics(
        from result: ProcessedConversionResult, for name: String
    ) {
        LogsView.logConversionStatistics(
            totalConvertedCount: result.totalConvertedCount,
            convertedCount: result.convertedCount,
            errorsCount: result.errorsCount,
            overLimit: result.overLimit,
            for: name
        )
    }

    func updateFilterListRuleCounts(
        filterList: FilterList,
        result: ProcessedConversionResult  // Update type here
    ) {
        filterList.standardRuleCount = result.convertedCount
        filterList.advancedRuleCount = result.advancedBlocking?.count ?? 0
        filterList.lastUpdated = Date()
    }

    private func convertRulesToAdGuardFormat(
        _ rules: [String], for name: String
            // Update here to use ProcessedConversionResult
    ) async throws -> ProcessedConversionResult {
        do {
            let result = try await convertToAdGuardFormat(rules)
            LogsView.logProcessingStep("Conversion completed", for: name)
            return result
        } catch {
            LogsView.logProcessingStep(
                "Conversion error: \(error.localizedDescription)", for: name)
            throw error
        }
    }

    func extractMetadata(from data: Data) throws -> (
        version: String, homepage: String?
    ) {
        guard let content = String(data: data, encoding: .utf8) else {
            throw FilterListError.invalidData
        }

        var version = "1.0.0"
        var homepage: String? = nil

        for line in content.components(separatedBy: .newlines) {
            let trimmedLine = line.trimmingCharacters(
                in: .whitespacesAndNewlines)
            if trimmedLine.hasPrefix("! Version:") {
                let extractedVersion = trimmedLine.replacingOccurrences(
                    of: "! Version:", with: ""
                ).trimmingCharacters(in: .whitespaces)
                if !extractedVersion.isEmpty {
                    version = extractedVersion
                }
            } else if trimmedLine.hasPrefix("! Homepage:") {
                homepage = trimmedLine.replacingOccurrences(
                    of: "! Homepage:", with: ""
                ).trimmingCharacters(in: .whitespaces)
            }
        }

        return (version, homepage)
    }

    func saveFilterList(
        to context: ModelContext,
        id: String,
        name: String,
        version: String,
        description: String,
        category: FilterListCategory,
        isEnabled: Bool,
        order: Int,
        homepageURL: String? = nil
    ) {
        let fetchDescriptor = FetchDescriptor<FilterList>(
            predicate: #Predicate { $0.id == id })
        if let filterList = try? context.fetch(fetchDescriptor).first {
            filterList.name = name
            filterList.version = version
            filterList.desc = description
            filterList.categoryString = category.rawValue
            filterList.isEnabled = isEnabled
            filterList.order = order
            if let homepageURL = homepageURL, !homepageURL.isEmpty {
                filterList.homepageURL = homepageURL
            }
        } else {
            let filterList = FilterList(
                name: name,
                version: version,
                desc: description,
                category: category,
                isEnabled: isEnabled,
                order: order,
                homepageURL: homepageURL
            )
            context.insert(filterList)
        }
    }

    func saveContentBlockerRules(
        to url: URL, conversionResults: [ProcessedConversionResult]
    ) async throws {
        let baseURL = url.deletingLastPathComponent()
        let blockerListURL = baseURL.appendingPathComponent("blockerList.json")
        let advancedBlockingURL = baseURL.appendingPathComponent(
            "advancedBlocking.json")

        LogsView.logProcessingStep(
            "Starting to write rules to \(blockerListURL.lastPathComponent) and \(advancedBlockingURL.lastPathComponent)",
            for: "FilterListProcessor"
        )

        // MARK: - Save Regular Rules
        try await saveRegularRules(
            to: blockerListURL, conversionResults: conversionResults)

        // MARK: - Save Advanced Blocking Rules
        try await saveAdvancedBlockingRules(
            to: advancedBlockingURL, conversionResults: conversionResults)

        // MARK: - Log Total Statistics
        logTotalStatistics(from: conversionResults)
    }

    private func saveRegularRules(
        to url: URL, conversionResults: [ProcessedConversionResult]
    ) async throws {
        var allRules: [Rule] = []

        for result in conversionResults {
            if let convertedString = result.converted,
                let convertedData = convertedString.data(using: .utf8)
            {
                do {
                    // Decode the JSON data into an array of dictionaries
                    if let jsonArray = try JSONSerialization.jsonObject(
                        with: convertedData, options: []) as? [[String: Any]]
                    {
                        // Convert each dictionary to a Rule and append to allRules
                        let rules = jsonArray.compactMap { ruleDict -> Rule? in
                            guard
                                let triggerDict = ruleDict["trigger"]
                                    as? [String: Any],
                                let actionDict = ruleDict["action"]
                                    as? [String: Any],
                                let trigger = try? JSONDecoder().decode(
                                    Rule.Trigger.self,
                                    from: JSONSerialization.data(
                                        withJSONObject: triggerDict)),
                                let action = try? JSONDecoder().decode(
                                    Rule.Action.self,
                                    from: JSONSerialization.data(
                                        withJSONObject: actionDict))
                            else {
                                return nil
                            }
                            return Rule(trigger: trigger, action: action)
                        }
                        allRules.append(contentsOf: rules)
                    }
                } catch {
                    LogsView.logProcessingStep(
                        "Failed to decode JSON array from string: \(error.localizedDescription)",
                        for: "FilterListProcessor"
                    )
                }
            }
        }

        guard !allRules.isEmpty else {
            LogsView.logProcessingStep(
                "No regular rules to write.", for: "FilterListProcessor")
            return
        }

        // Encode and save the rules
        let encoder = JSONEncoder()
        encoder.outputFormatting = .prettyPrinted

        do {
            let jsonData = try encoder.encode(allRules)
            try jsonData.write(to: url)
            LogsView.logProcessingStep(
                "Successfully wrote \(allRules.count) regular rules to \(url.absoluteString)",
                for: "FilterListProcessor"
            )
        } catch {
            LogsView.logProcessingStep(
                "Failed to encode or write regular rules: \(error.localizedDescription)",
                for: "FilterListProcessor"
            )
            throw error
        }
    }

    private func saveAdvancedBlockingRules(
        to url: URL, conversionResults: [ProcessedConversionResult]  // Update type here
    ) async throws {
        // 1. Extract Advanced Rules
        let advancedRules = conversionResults.flatMap {
            $0.advancedBlocking ?? []  // Access advancedBlocking directly
        }

        // 2. Handle Empty Rules Case
        guard !advancedRules.isEmpty else {
            LogsView.logProcessingStep(
                "No advanced blocking rules to write.",
                for: "FilterListProcessor"
            )
            return
        }

        // 3. Encode and Save Rules
        try await encodeAndSaveRules(advancedRules, to: url)

        // 4. Log Success
        LogsView.logProcessingStep(
            "Successfully wrote advanced blocking rules to \(url.absoluteString)",
            for: "FilterListProcessor"
        )
    }

    // Helper function to encode and save rules to a file
    private func encodeAndSaveRules(_ rules: [ContentBlockerRule], to url: URL)
        async throws
    {

        let encoder = JSONEncoder()
        encoder.outputFormatting = .prettyPrinted

        do {
            let jsonData = try encoder.encode(rules)
            try jsonData.write(to: url)
        } catch {
            LogsView.logProcessingStep(
                "Failed to encode or write advanced blocking rules: \(error.localizedDescription)",
                for: "FilterListProcessor"
            )
            throw error
        }
    }

    private func logTotalStatistics(
        from conversionResults: [ProcessedConversionResult]
    ) {
        let totalStats = conversionResults.reduce((0, 0, 0, false)) {
            result, current in
            (
                result.0 + current.totalConvertedCount,
                result.1 + current.convertedCount,
                result.2 + current.errorsCount,
                result.3 || current.overLimit
            )
        }

        LogsView.logProcessingStep(
            """

            === Total Statistics ===
            Total rules processed: \(totalStats.0)
            Successfully converted: \(totalStats.1)
            Total errors: \(totalStats.2)
            Over limit: \(totalStats.3)
            """,
            for: "FilterListProcessor"
        )
    }
}

// WebShieldApp/Model/FilterList/FilterListProvider.swift
import Foundation

enum FilterListProvider {

    static let filterListData: [FilterListData] = [
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard – Ads",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/2_optimized.txt",
            category: .ads,
            isSelected: true,
            description:
                "EasyList + AdGuard English filter. This filter is necessary for quality ad blocking.",
            homepageURL:
                "https://github.com/AdguardTeam/AdguardFilters#adguard-filters",
            informationURL:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard – Mobile Ads",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/11_optimized.txt",
            category: .ads,
            isSelected: false,
            description:
                "Filter for all known mobile ad networks. Useful for mobile devices.",
            homepageURL:
                "https://github.com/AdguardTeam/AdguardFilters#adguard-filters",
            informationURL:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "EasyList",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/101_optimized.txt",
            category: .ads,
            isSelected: false,
            description:
                "EasyList is the primary subscription that removes adverts from web pages in English. Already included in AdGuard Base filter.",
            homepageURL: "https://easylist.to/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard Tracking Protection",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/3_optimized.txt",
            category: .privacy,
            isSelected: true,
            description:
                "The most comprehensive list of various online counters and web analytics tools. Use this filter if you do not want your actions on the Internet to be tracked.",
            homepageURL:
                "https://github.com/AdguardTeam/AdguardFilters#adguard-filters",
            informationURL:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "EasyPrivacy",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/118_optimized.txt",
            category: .privacy,
            isSelected: true,
            description:
                "Privacy protection supplement for EasyList.",
            homepageURL: "https://easylist.to/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "Online Malicious URL Blocklist",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/208_optimized.txt",
            category: .security,
            isSelected: false,
            description:
                "Blocks domains that are known to be used to propagate malware and spyware.",
            homepageURL:
                "https://gitlab.com/malware-filter/urlhaus-filter#malicious-url-blocklist"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "Phishing URL Blocklist",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/255_optimized.txt",
            category: .security,
            isSelected: false,
            description:
                "Phishing URL blocklist for uBlock Origin (uBO), AdGuard, Vivaldi, Pi-hole, Hosts file, Dnsmasq, BIND, Unbound, Snort and Suricata.",
            homepageURL:
                "https://gitlab.com/malware-filter/phishing-filter#phishing-url-blocklist"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "Peter Lowe’s Ad and tracking server list",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/204_optimized.txt",
            category: .multipurpose,
            isSelected: false,
            description:
                "Filter that blocks ads, trackers, and other nasty things.",
            homepageURL: "https://pgl.yoyo.org/adservers/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard – Cookie Notices",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/18_optimized.txt",
            category: .cookies,
            isSelected: false,
            description:
                "Blocks cookie notices on web pages.",
            homepageURL:
                "https://github.com/AdguardTeam/AdguardFilters#adguard-filters",
            informationURL:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "EasyList – Cookie Notices",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/241_optimized.txt",
            category: .cookies,
            isSelected: false,
            description:
                "Removes cookie and privacy warnings. Already included in Fanboy's Annoyances list.",
            homepageURL: "https://github.com/easylist/easylist#fanboy-lists"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard – Social Widgets",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/4_optimized.txt",
            category: .social,
            isSelected: false,
            description:
                "Filter for social media widgets such as 'Like' and 'Share' buttons and more.",
            homepageURL:
                "https://github.com/AdguardTeam/AdguardFilters#adguard-filters",
            informationURL:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "Fanboy – Social Blocking",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/123_optimized.txt",
            category: .social,
            isSelected: false,
            description:
                "Hides and blocks social content, social widgets, social scripts and social icons. Already included in Fanboy's Annoyances list.",
            homepageURL: "https://github.com/ryanbr/fanboy-adblock/issues"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "Fanboy – Anti-Facebook",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/225_optimized.txt",
            category: .social,
            isSelected: false,
            description:
                "Warning, it will break Facebook-based comments on some websites and may also break some Facebook apps or games.",
            homepageURL: "https://github.com/ryanbr/fanboy-adblock/issues"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard – Annoyances",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/14_optimized.txt",
            category: .annoyances,
            isSelected: false,
            description:
                "Blocks irritating elements on web pages including cookie notices, third-party widgets and in-page pop-ups. Contains the following AdGuard filters: Cookie Notices, Popups, Mobile App Banners, Other Annoyances and Widgets.",
            homepageURL:
                "https://github.com/AdguardTeam/AdguardFilters#adguard-filters",
            informationURL:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard – Popup Overlays",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/19_optimized.txt",
            category: .annoyances,
            isSelected: false,
            description:
                "Blocks all kinds of pop-ups that are not necessary for websites' operation according to our Filter policy.",
            homepageURL:
                "https://github.com/AdguardTeam/AdguardFilters#adguard-filters",
            informationURL:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard – Mobile App Banners",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/20_optimized.txt",
            category: .annoyances,
            isSelected: false,
            description:
                "Blocks all kinds of pop-ups that are not necessary for websites' operation according to our Filter policy.",
            homepageURL:
                "https://github.com/AdguardTeam/AdguardFilters#adguard-filters",
            informationURL:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard – Other Annoyances",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/21_optimized.txt",
            category: .annoyances,
            isSelected: false,
            description:
                "Blocks irritating elements on web pages that do not fall under the popular categories of annoyances.",
            homepageURL:
                "https://github.com/AdguardTeam/AdguardFilters#adguard-filters",
            informationURL:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard – Widgets",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/22_optimized.txt",
            category: .annoyances,
            isSelected: false,
            description:
                "Blocks annoying third-party widgets: online assistants, live support chats, etc.",
            homepageURL:
                "https://github.com/AdguardTeam/AdguardFilters#adguard-filters",
            informationURL:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "Fanboy – Annoyances",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/122_optimized.txt",
            category: .annoyances,
            isSelected: false,
            description:
                "Removes in-page pop-ups and other annoyances. Includes Fanboy's Social Blocking & EasyList Cookie Lists.",
            homepageURL: "https://github.com/ryanbr/fanboy-adblock/issues"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "ru",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/1_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Filter that enables ad blocking on websites in Russian language.",
            homepageURL:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString, name: "de",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/6_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "EasyList Germany + AdGuard German filter. Filter list that specifically removes ads on websites in German language.",
            homepageURL:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard – Experimental",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/5_optimized.txt",
            category: .experimental,
            isSelected: false,
            description:
                "Filter designed to test certain hazardous filtering rules before they are added to the basic filters.",
            homepageURL:
                "https://github.com/AdguardTeam/AdguardFilters#adguard-filters"
        ),
    ]

    static func filterListDataById(_ id: String) -> FilterListData? {
        return filterListData.first(where: { $0.id == id })
    }
}

// WebShieldApp/Model/FilterList/FilterListSection.swift
import Foundation

struct FilterListSection: Identifiable {
    let title: String
    let filterLists: [FilterList]
    let category: FilterListCategory
    var id: String { title }
}

// WebShieldApp/Model/FilterList/TotalStats.swift
struct TotalStats {
    var totalConvertedCount: Int = 0
    var convertedCount: Int = 0
    var errorsCount: Int = 0
    var overLimit: Int = 0
}

// WebShieldApp/Model/GroupContainerURL.swift
import Foundation

@MainActor
struct GroupContainerURL {
    private static let fileManager: FileManager = FileManager.default
    static func groupContainerURL() -> URL? {
        return fileManager.containerURL(
            forSecurityApplicationGroupIdentifier:
                Identifiers.groupID)
    }
}

// WebShieldApp/Model/Identifiers.swift
import Foundation

public enum Identifiers {
    static let groupID: String = "G5S45S77DF.me.arjuna.WebShield"
}

// WebShieldApp/Model/TrustedSite.swift
import Foundation
import SwiftData
import SwiftUI

@Model
final class TrustedSite {
    @Attribute(.unique) var id: String
    var domain: String

    init(domain: String) {
        self.id = UUID().uuidString
        self.domain = domain
    }
}

// WebShieldApp/Model/WSLogger.swift
import Foundation

@MainActor
class WSLogger {
    static var logs: [String] = []

    static func log(_ message: String) {
        logs.append(message)
    }
}

// WebShieldApp/View/ContentView.swift
@preconcurrency import ContentBlockerConverter
import Foundation
import SwiftData
import SwiftUI

struct ContentView: View {
    @Environment(\.modelContext) private var modelContext
    @Query(sort: \FilterList.order, order: .forward) private var filterLists:
        [FilterList]
    @State private var selectedCategory: FilterListCategory = .all
    @State private var isUpdating = false
    @State private var showingLogs = false
    @State private var showingImport = false
    @State private var progress: Double = 0
    @State private var currentList: Int = 0
    @State private var totalLists: Int = 0
    private let filterListProcessor = FilterListProcessor()
    @State private var columnVisibility = NavigationSplitViewVisibility
        .all

    var body: some View {
        NavigationSplitView(columnVisibility: $columnVisibility) {
            List(selection: $selectedCategory) {
                Section {
                    let categories: [FilterListCategory] = [
                        .all, .regional, .custom,
                    ]
                    ForEach(categories, id: \.self) { category in
                        NavigationLink(value: category) {
                            Label(
                                category.rawValue,
                                systemImage: category.systemImage
                            )
                        }
                    }
                } header: {
                    Text("Categories")
                }
            }
            .navigationTitle("WebShield")
            .toolbar(removing: .sidebarToggle)
        } detail: {
            VStack(spacing: 0) {
                if isUpdating {
                    ProgressView(value: progress, total: 1.0)
                        .progressViewStyle(.linear)
                        .tint(.blue)
                }

                FilterListView(category: selectedCategory)
                    .navigationTitle(selectedCategory.rawValue)
                    .toolbar {
                        ToolbarItemGroup(placement: .automatic) {
                            Button(action: { resetModel() }) {
                                Label("Reset", systemImage: "trash")
                            }
                            .help("Reset Model")

                            Button(action: { refreshFilters() }) {
                                Label("Refresh", systemImage: "arrow.clockwise")
                            }
                            .help("Refresh Filters")
                            .disabled(isUpdating)

                            Button(action: { showingLogs.toggle() }) {
                                Label(
                                    "Logs",
                                    systemImage: "doc.text.magnifyingglass")
                            }
                            .help("View Logs")

                            Button(action: { showingImport.toggle() }) {
                                Label("Import", systemImage: "plus")
                            }
                            .help("Import Filters")
                        }
                    }
                    .sheet(isPresented: $showingLogs) {
                        LogsView()
                    }
                    .sheet(isPresented: $showingImport) {
                        ImportView()
                    }
            }
        }
    }

    private var enabledFilterCount: Int {
        filterLists.filter { $0.isEnabled }.count
    }

    private var totalRuleCount: Int {
        // Read both blockerList.json and advancedBlocking.json to get the combined rule count

        var combinedRuleCount = 0

        // Read blockerList.json (regular rules)
        if let blockerListURL = GroupContainerURL.groupContainerURL()?
            .appendingPathComponent("blockerList.json"),
            let blockerListData = try? Data(contentsOf: blockerListURL)
        {
            if let rules = try? JSONDecoder().decode(
                [Rule].self, from: blockerListData)
            {
                combinedRuleCount += rules.count
            }
        }

        // Read advancedBlocking.json (advanced rules)
        if let advancedBlockingURL = GroupContainerURL.groupContainerURL()?
            .appendingPathComponent("advancedBlocking.json"),
            let advancedBlockingData = try? Data(
                contentsOf: advancedBlockingURL)
        {
            if let rules = try? JSONDecoder().decode(
                [ContentBlockerRule].self, from: advancedBlockingData
            ) {
                combinedRuleCount += rules.count
            }
        }

        return combinedRuleCount
    }

    private func shouldShowSection(_ category: FilterListCategory) -> Bool {
        selectedCategory == .all || category == selectedCategory
    }

    private var groupedFilterLists: [FilterListSection] {
        let categoryOrder: [FilterListCategory] = [
            .ads, .privacy, .security, .multipurpose,
            .social, .cookies, .annoyances, .regional,
            .experimental, .custom,
        ]

        let sortedLists = filterLists.sorted { $0.order < $1.order }
        var sections: [FilterListCategory: [FilterList]] = [:]

        for list in sortedLists {
            if let category = list.category {
                sections[category, default: []].append(list)
            }
        }

        return categoryOrder.compactMap { category in
            if let lists = sections[category], !lists.isEmpty {
                return FilterListSection(
                    title: category.rawValue,
                    filterLists: lists,
                    category: category
                )
            }
            return nil
        }
    }

    private func resetModel() {
        do {
            try modelContext.delete(model: FilterList.self)
            try modelContext.save()
            seedDataIfNeeded()
        } catch {
            print("Failed to reset model: \(error)")
        }
    }

    private func refreshFilters() {
        Task {
            isUpdating = true
            progress = 0
            currentList = 0

            defer {
                isUpdating = false
                progress = 0
                currentList = 0
                totalLists = 0
            }

            LogsView.logRefreshStart()

            let fetchDescriptor = FetchDescriptor<FilterList>(
                predicate: #Predicate { $0.isEnabled == true }
            )

            guard let enabledLists = try? modelContext.fetch(fetchDescriptor)
            else {
                LogsView.logProcessingStep(
                    "Failed to fetch enabled filter lists", for: "System")
                return
            }

            totalLists = enabledLists.count
            var allConversionResults: [ProcessedConversionResult] = []

            for (index, enabledList) in enabledLists.enumerated() {
                do {
                    let (conversionResult, version, homepage):
                        (ProcessedConversionResult, String, String?)

                    if let providerData = FilterListProvider.filterListData
                        .first(where: {
                            $0.name == enabledList.name
                        })
                    {
                        (conversionResult, version, homepage) =
                            try await filterListProcessor.downloadAndParse(
                                from: URL(string: providerData.urlString)!,
                                id: enabledList.id,
                                name: enabledList.name,
                                existingHomepage: enabledList.homepageURL
                            )
                    } else if let urlString = enabledList.urlString,
                        let url = URL(string: urlString)
                    {
                        (conversionResult, version, homepage) =
                            try await filterListProcessor.downloadAndParse(
                                from: url,
                                id: enabledList.id,
                                name: enabledList.name,
                                existingHomepage: enabledList.homepageURL
                            )
                    } else {
                        LogsView.logProcessingStep(
                            "No URL found for filter list",
                            for: enabledList.name)
                        continue
                    }

                    enabledList.version = version
                    if enabledList.homepageURL == nil
                        || enabledList.homepageURL?.isEmpty == true
                    {
                        enabledList.homepageURL = homepage
                    }
                    allConversionResults.append(conversionResult)

                    // Update rule counts in SwiftData
                    filterListProcessor.updateFilterListRuleCounts(
                        filterList: enabledList,
                        result: conversionResult
                    )

                    await MainActor.run {
                        currentList = index + 1
                        progress = Double(currentList) / Double(totalLists)
                    }

                } catch {
                    LogsView.logProcessingStep(
                        "Failed to process: \(error.localizedDescription)",
                        for: enabledList.name
                    )
                }
            }

            // Save conversion results
            do {
                let blockerListURL = GroupContainerURL.groupContainerURL()?
                    .appendingPathComponent("blockerList.json")

                if let url = blockerListURL {
                    try await filterListProcessor.saveContentBlockerRules(
                        to: url,
                        conversionResults: allConversionResults
                    )
                }

                // Save the changes to SwiftData
                try modelContext.save()

            } catch {
                print("Failed to save conversion results: \(error)")
            }
        }
    }

    private func seedDataIfNeeded() {
        for (index, data) in FilterListProvider.filterListData.enumerated() {
            filterListProcessor.saveFilterList(
                to: modelContext,
                id: data.id,
                name: data.name,
                version: "N/A",
                description: data.description,
                category: data.category,
                isEnabled: data.isSelected,
                order: index,
                homepageURL: data.homepageURL
            )
        }
        try? modelContext.save()
    }
}

// WebShieldApp/View/FilterList/FilterListRow.swift
import Foundation
import SwiftUI

struct FilterListRow: View {
    let filterList: FilterList
    @Environment(\.openURL) private var openURL
    @Environment(\.modelContext) private var modelContext

    private var providerData: FilterListData? {
        FilterListProvider.filterListData.first { $0.name == filterList.name }
    }

    var body: some View {
        HStack(alignment: .center, spacing: 16) {
            VStack(alignment: .leading, spacing: 12) {
                HStack(alignment: .firstTextBaseline, spacing: 4) {
                    Text(filterList.name)
                        .font(.headline)

                    if let homepage = filterList.homepageURL,
                        let url = URL(string: homepage)
                    {
                        Button {
                            openURL(url)
                        } label: {
                            Label("Homepage", systemImage: "house")
                        }
                        .labelStyle(.iconOnly)
                        .buttonStyle(.plain)
                        .foregroundStyle(.secondary)
                        .help("Open Homepage")
                    }

                    if let urlString =
                        (providerData?.urlString ?? filterList.urlString),
                        let url = URL(string: urlString)
                    {
                        Button {
                            openURL(url)
                        } label: {
                            Label("View Source", systemImage: "eye")
                        }
                        .labelStyle(.iconOnly)
                        .buttonStyle(.plain)
                        .foregroundStyle(.secondary)
                        .help("View Filter Source")
                    }

                    if let infoURL = providerData?.informationURL,
                        let url = URL(string: infoURL)
                    {
                        Button {
                            openURL(url)
                        } label: {
                            Label("Information", systemImage: "info.circle")
                        }
                        .labelStyle(.iconOnly)
                        .buttonStyle(.plain)
                        .foregroundStyle(.secondary)
                        .help("View Filter Information")
                    }
                }

                Text(filterList.desc)
                    .font(.subheadline)
                    .foregroundStyle(.secondary)
                    .lineLimit(2)

                HStack(spacing: 4) {
                    Text("\(filterList.totalRuleCount) rules")
                        .font(.footnote)
                        .foregroundStyle(.secondary)

                    Text("•")
                        .font(.footnote)
                        .foregroundStyle(.secondary)

                    Text("Version \(filterList.version)")
                        .font(.footnote)
                        .foregroundStyle(.secondary)
                }

                // Add the last updated date
                Text(
                    "Last Updated: \(filterList.lastUpdated, formatter: itemFormatter)"
                )
                .font(.footnote)
                .foregroundStyle(.secondary)
            }
            .padding(.vertical, 8)

            Spacer()

            Toggle(
                "Enable Filter",
                isOn: Binding(
                    get: { filterList.isEnabled },
                    set: { newValue in
                        filterList.isEnabled = newValue
                        try? modelContext.save()
                    }
                )
            )
            .toggleStyle(.switch)
            .labelsHidden()
        }
    }
}

// Date formatter for a more readable date
private let itemFormatter: DateFormatter = {
    let formatter = DateFormatter()
    formatter.dateStyle = .medium
    formatter.timeStyle = .short
    return formatter
}()

// WebShieldApp/View/FilterList/FilterListToggle.swift
import SwiftUI

struct FilterListToggle: View {
    let filterList: FilterList
    let onToggle: (Bool) -> Void

    var body: some View {
        Toggle(
            isOn: Binding(
                get: { filterList.isEnabled },
                set: { newValue in
                    onToggle(newValue)
                }
            )
        ) {
            // No label needed since it's handled in the parent view
            EmptyView()
        }
        .toggleStyle(SwitchToggleStyle())
        .labelsHidden()
    }
}

// WebShieldApp/View/FilterList/FilterListView.swift
import SwiftData
import SwiftUI

struct FilterListView: View {
    var category: FilterListCategory
    @Query(sort: \FilterList.order, order: .forward) private var filterLists:
        [FilterList]
    @Environment(\.modelContext) private var modelContext
    @State private var searchText: String = ""

    private var filteredLists: [FilterList] {
        filterLists.filter { filterList in
            // Match category if it's not `.all`
            let categoryMatches =
                (category == .all || filterList.category == category)

            // Match name if user typed something in search bar
            let nameMatches =
                searchText.isEmpty
                || filterList.name.localizedCaseInsensitiveContains(searchText)

            return categoryMatches && nameMatches
        }
    }

    private var enabledCount: Int {
        filteredLists.filter { $0.isEnabled }.count
    }

    private var totalRules: Int {
        filteredLists.filter { $0.isEnabled }.reduce(0) {
            $0 + $1.totalRuleCount
        }
    }

    var body: some View {
        List {
            if !filteredLists.isEmpty {
                Section {
                    HStack(spacing: 16) {
                        ZStack {
                            RoundedRectangle(cornerRadius: 8)
                                .fill(.blue.opacity(0.15))
                                .frame(width: 36, height: 36)

                            Image(systemName: "shield")
                                .imageScale(.medium)
                                .foregroundStyle(.blue)
                                .fontWeight(.semibold)
                        }

                        VStack(alignment: .leading, spacing: 4) {
                            HStack(alignment: .firstTextBaseline, spacing: 0) {
                                Text("\(enabledCount)")
                                    .font(.title2)
                                    .bold()
                                    .frame(width: 45, alignment: .leading)
                                    .padding(.horizontal)
                                //                                Text("•")
                                //                                    .font(.title2)
                                //                                    .foregroundStyle(.secondary)
                                //                                    .frame(width: 32, alignment: .center)
                                Text("\(totalRules)")
                                    .font(.title2)
                                    .bold()
                                    .frame(alignment: .leading)
                            }

                            HStack(alignment: .firstTextBaseline, spacing: 0) {
                                Text("Enabled")
                                    .font(.subheadline)
                                    .foregroundStyle(.secondary)
                                    .frame(width: 45, alignment: .leading)
                                    .padding(.horizontal)
                                //                                Text("•")
                                //                                    .font(.subheadline)
                                //                                    .foregroundStyle(.secondary)
                                //                                    .frame(width: 32, alignment: .center)
                                Text("Rules")
                                    .font(.subheadline)
                                    .foregroundStyle(.secondary)
                                    .frame(alignment: .leading)
                            }
                        }

                        Spacer()
                    }
                    .padding(.vertical, 8)
                }
            }

            ForEach(groupedFilterLists, id: \.id) { section in
                Section {
                    ForEach(section.filterLists) { filterList in
                        FilterListRow(filterList: filterList)
                            .swipeActions(
                                edge: .trailing, allowsFullSwipe: true
                            ) {
                                if filterList.category == .custom {
                                    Button(role: .destructive) {
                                        withAnimation {
                                            deleteFilterList(filterList)
                                        }
                                    } label: {
                                        Label("Delete", systemImage: "trash")
                                    }
                                }
                            }
                    }
                } header: {
                    Text(section.title)
                        .font(.headline)
                        .textCase(.none)
                        .foregroundStyle(.primary)
                }
            }
        }
        .listStyle(.automatic)
        .searchable(text: $searchText)
    }

    private var groupedFilterLists: [FilterListSection] {
        let sortedLists = filteredLists.sorted { $0.order < $1.order }
        var sections: [FilterListCategory: [FilterList]] = [:]

        for list in sortedLists {
            if let category = list.category {
                sections[category, default: []].append(list)
            }
        }

        // Define category order with custom at the end
        let categoryOrder: [FilterListCategory] = [
            .ads, .privacy, .security, .multipurpose,
            .social, .cookies, .annoyances, .regional,
            .experimental,
        ]

        var orderedSections = categoryOrder.compactMap { category in
            if let lists = sections[category], !lists.isEmpty {
                return FilterListSection(
                    title: category.rawValue,
                    filterLists: lists,
                    category: category
                )
            }
            return nil
        }

        // Add custom section at the end if it exists
        if let customLists = sections[.custom], !customLists.isEmpty {
            orderedSections.append(
                FilterListSection(
                    title: FilterListCategory.custom.rawValue,
                    filterLists: customLists,
                    category: .custom
                )
            )
        }

        return orderedSections
    }

    private func deleteFilterList(_ filterList: FilterList) {
        modelContext.delete(filterList)
        do {
            try modelContext.save()
        } catch {
            print("Failed to delete filter list: \(error)")
        }
    }
}

// WebShieldApp/View/Navbar/SidebarView.swift
import SwiftData
import SwiftUI

struct SidebarView: View {
    @Binding var selectedCategory: FilterListCategory
    @Query(sort: \FilterList.categoryString, order: .forward) var filterLists:
        [FilterList]
    @State private var showingImport = false

    // 1. Use a regular List without selection binding
    var body: some View {
        VStack {
            Text("Categories")
                .font(.title3)
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding([.top, .leading])
            List {
                ForEach(
                    [FilterListCategory.all, .regional, .custom], id: \.self
                ) { category in
                    NavigationLink(destination: destinationView(for: category))
                    {
                        HStack {
                            Image(systemName: category.systemImage)
                            Text(category.rawValue)
                        }
                        .font(.system(size: 14))
                        .foregroundColor(.secondary)
                    }
                }
            }
            .listStyle(SidebarListStyle())

            Spacer()  // Push the button to the bottom

            // 2. Import button outside the List
            Button(action: {
                showingImport = true
            }) {
                Label("Import", systemImage: "plus")
            }
            .buttonStyle(.borderedProminent)
            .padding()
            .frame(maxWidth: .infinity)
            .background(.ultraThickMaterial)
            .cornerRadius(10)
            .padding(.bottom, 8)
        }
        .navigationTitle("")  // Optional: Remove the navigation title if it's not needed here
        .sheet(isPresented: $showingImport) {
            ImportView()
        }
    }

    // Helper function to create destination views
    private func destinationView(for category: FilterListCategory) -> some View
    {
        FilterListView(category: category)
    }
}

// WebShieldApp/View/Navbar/Toolbar/ImportView.swift
@preconcurrency import ContentBlockerConverter
import Foundation
import SwiftData
import SwiftUI

@MainActor
struct ImportView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.modelContext) private var modelContext

    @State private var urls: [String] = [""]
    @State private var isImporting = false
    let filterListProcessor = FilterListProcessor()

    var body: some View {
        VStack(spacing: 0) {
            // Header
            HStack {
                Text("Import Filter Lists")
                    .font(.headline)
                Spacer()
                Button("Done") {
                    dismiss()
                }
                .buttonStyle(.borderless)
            }
            .padding()
            .background(Color(.windowBackgroundColor))

            Divider()

            // Content
            ScrollView {
                VStack(alignment: .leading, spacing: 16) {
                    Text("Enter filter list URLs (one per line)")
                        .foregroundStyle(.secondary)
                        .padding(.horizontal)

                    VStack(spacing: 8) {
                        ForEach(urls.indices, id: \.self) { index in
                            HStack {
                                TextField(
                                    "https://example.com/filterlist.txt",
                                    text: $urls[index]
                                )
                                .textFieldStyle(.roundedBorder)

                                if urls.count > 1 {
                                    Button(role: .destructive) {
                                        urls.remove(at: index)
                                    } label: {
                                        Image(systemName: "minus.circle.fill")
                                    }
                                    .buttonStyle(.borderless)
                                }
                            }
                        }
                    }
                    .padding(.horizontal)

                    Button {
                        urls.append("")
                    } label: {
                        Label("Add URL", systemImage: "plus.circle.fill")
                    }
                    .buttonStyle(.borderless)
                    .padding(.horizontal)
                }
                .padding(.vertical)
            }

            Divider()

            // Footer
            HStack {
                Spacer()
                Button("Import", action: importFilterLists)
                    .buttonStyle(.borderedProminent)
                    .disabled(isImporting || urls.allSatisfy { $0.isEmpty })
            }
            .padding()
            .background(Color(.windowBackgroundColor))
        }
        .frame(width: 500, height: 400)
    }

    private func importFilterLists() {
        Task {
            isImporting = true
            defer { isImporting = false }

            let validUrls = urls.filter { !$0.isEmpty }
                .compactMap {
                    URL(string: $0.trimmingCharacters(in: .whitespaces))
                }

            for url in validUrls {
                do {
                    // Download and extract metadata
                    let data = try await filterListProcessor.downloadFilterList(
                        from: url)
                    guard let content = String(data: data, encoding: .utf8)
                    else {
                        throw FilterListError.invalidData
                    }

                    // Extract metadata
                    var title = url.lastPathComponent
                    var version = "0.0.0"
                    var description = "Imported filter list"

                    for line in content.components(separatedBy: .newlines) {
                        if line.hasPrefix("! Title:") {
                            title = line.replacingOccurrences(
                                of: "! Title:", with: ""
                            )
                            .trimmingCharacters(in: .whitespaces)
                        } else if line.hasPrefix("! Version:") {
                            version = line.replacingOccurrences(
                                of: "! Version:", with: ""
                            )
                            .trimmingCharacters(in: .whitespaces)
                        } else if line.hasPrefix("! Description:") {
                            description = line.replacingOccurrences(
                                of: "! Description:", with: ""
                            )
                            .trimmingCharacters(in: .whitespaces)
                        }
                    }

                    // Create new filter list
                    let filterList = FilterList(
                        name: title,
                        version: version,
                        desc: description,
                        category: .custom,
                        isEnabled: true
                    )
                    filterList.urlString = url.absoluteString

                    modelContext.insert(filterList)
                    LogsView.logProcessingStep(
                        "Added new filter list: \(title)",
                        for: "Import"
                    )
                } catch {
                    LogsView.logProcessingStep(
                        "Failed to import: \(error.localizedDescription)",
                        for: url.absoluteString
                    )
                }
            }

            do {
                try modelContext.save()
                LogsView.logProcessingStep(
                    "Successfully imported \(validUrls.count) filter lists",
                    for: "Import"
                )
            } catch {
                LogsView.logProcessingStep(
                    "Failed to save filter lists: \(error.localizedDescription)",
                    for: "Import"
                )
            }

            dismiss()
        }
    }
}

// WebShieldApp/View/Navbar/Toolbar/LogsView.swift
import ContentBlockerConverter
import Foundation
import SwiftUI
import os.log

@MainActor
struct LogsView: View {
    @Environment(\.dismiss) private var dismiss
    @State private var searchText = ""

    static let shared = LogsView()
    private static var logEntries: [String] = []

    var body: some View {
        VStack(spacing: 0) {
            // Header
            HStack {
                Text("Logs")
                    .font(.headline)
                Spacer()
                Button(action: copyLogs) {
                    Label("Copy", systemImage: "doc.on.doc")
                }
                .buttonStyle(.borderless)
                Button("Done") {
                    dismiss()
                }
                .buttonStyle(.borderless)
            }
            .padding()
            .background(Color(.windowBackgroundColor))

            Divider()

            // Log content
            ScrollView {
                Text(Self.logEntries.joined(separator: "\n"))
                    .font(.system(.body, design: .monospaced))
                    .textSelection(.enabled)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .padding()
            }
            .background(Color(.textBackgroundColor))
        }
        .frame(width: 600, height: 400, alignment: .top)
    }

    private func copyLogs() {
        #if os(macOS)
            NSPasteboard.general.clearContents()
            NSPasteboard.general.setString(
                Self.logEntries.joined(separator: "\n"),
                forType: .string
            )
        #else
            UIPasteboard.general.string = Self.logEntries.joined(
                separator: "\n")
        #endif
    }

    // Static methods to add logs
    static func logConversionStatistics(
        totalConvertedCount: Int,
        convertedCount: Int,
        errorsCount: Int,
        overLimit: Bool,
        for listName: String
    ) {
        let message = """

            Conversion statistics for \(listName):
            - Total converted count: \(totalConvertedCount)
            - Converted count: \(convertedCount)
            - Errors count: \(errorsCount)
            - Over limit: \(overLimit)

            """
        addLog(message)
    }

    static func logTotalStatistics(_ stats: TotalStats) {
        let message = """

            Total conversion statistics:
            - Total converted count: \(stats.totalConvertedCount)
            - Converted count: \(stats.convertedCount)
            - Errors count: \(stats.errorsCount)
            - Lists over limit: \(stats.overLimit)

            """
        addLog(message)
    }

    static func logProcessingStep(_ step: String, for listName: String) {
        let timestamp = DateFormatter.localizedString(
            from: Date(),
            dateStyle: .none,
            timeStyle: .medium
        )
        addLog("[\(timestamp)] \(listName): \(step)")
    }

    static func logRefreshStart() {
        let message = """


            ==========================================
                        STARTING REFRESH
            ==========================================

            """
        addLog(message)
    }

    private static func addLog(_ message: String) {
        print("\(message)")
        logEntries.append(message)
        if logEntries.count > 1000 {
            logEntries.removeFirst(logEntries.count - 1000)
        }
    }
}

// WebShieldApp/View/Navbar/Toolbar/NativeStyleTextEditor.swift
import Foundation
import SwiftUI

struct NativeStyleTextEditor: View {
    @Binding var text: String
    var placeholder: String

    var body: some View {
        ZStack(alignment: .topLeading) {
            if text.isEmpty {
                Text(placeholder)
                    //                    .foregroundColor(Color(.placeholderTextColor))
                    .padding(.horizontal, 8)
                    .padding(.vertical, 12)
            }
            TextEditor(text: $text)
                .padding(4)
        }
        .font(.body)
        .overlay(
            RoundedRectangle(cornerRadius: 8)
                .stroke(Color(.systemGray), lineWidth: 1)
        )
        //        .background(Color(.textBackgroundColor))
    }
}

// WebShieldApp/ViewModel/ContentViewModel.swift
import Foundation
import SwiftData

final class ContentViewModel: ObservableObject {
    @Published var selectedCategory: FilterListCategory = .all

    @MainActor
    init(context: ModelContext) {

    }
}

// WebShieldApp/WebShieldApp.swift
import Foundation
import SafariServices
import SwiftData
import SwiftUI

@main
struct WebShieldApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
                .modelContainer(
                    for: FilterList.self,
                    isAutosaveEnabled: true)
        }
    }
}

// WebShieldContentBlocker/ContentBlockerRequestHandler.swift
import Foundation

class ContentBlockerRequestHandler: NSObject, NSExtensionRequestHandling {
    func beginRequest(with context: NSExtensionContext) {
        let requiredPart = "G5S45S77DF.me.arjuna.WebShield"

        guard
            let containerURL = FileManager.default.containerURL(
                forSecurityApplicationGroupIdentifier: requiredPart)
        else {
            print(
                "Error: Could not get container URL for group \(requiredPart)")
            context.completeRequest(returningItems: nil, completionHandler: nil)
            return
        }

        let blockerlistURL = containerURL.appendingPathComponent(
            "blockerList.json")  // Use appendingPathComponent

        guard FileManager.default.fileExists(atPath: blockerlistURL.path) else {
            print("Content Blocker Error: blockerList.json does not exist")
            context.completeRequest(returningItems: nil, completionHandler: nil)
            return
        }

        // Use if let instead of force unwrapping
        if let attachment = NSItemProvider(contentsOf: blockerlistURL) {
            let item = NSExtensionItem()
            item.attachments = [attachment]
            context.completeRequest(
                returningItems: [item], completionHandler: nil)
        } else {
            print(
                "Error: Could not create NSItemProvider for \(blockerlistURL)")
            context.completeRequest(returningItems: nil, completionHandler: nil)
        }
    }
}

// WebShieldExtra/ContentBlockerEngineWrapper.swift
@preconcurrency import ContentBlockerEngine
import Foundation
import os.log

final class ContentBlockerEngineWrapper: Sendable {
    private let contentBlockerEngine: ContentBlockerEngine
    static let shared = ContentBlockerEngineWrapper()
    private let logger = Logger(
        subsystem: "me.arjuna.WebShield",
        category: "ContentBlockerEngineWrapper")

    private init() {
        let requiredPart: String = "G5S45S77DF.me.arjuna.WebShield"
        let advancedBlockingURL =
            ContentBlockerEngineWrapper.getAdvancedBlockingURL(
                forGroupIdentifier: requiredPart)

        // Log the URL
        logger.log(
            "advancedBlocking.json URL: \(advancedBlockingURL.absoluteString, privacy: .public)"
        )

        // Load and parse JSON, or use empty rules as a fallback
        let json = ContentBlockerEngineWrapper.loadJSON(
            fromURL: advancedBlockingURL, logger: logger)

        // Attempt to create the engine or log an error
        self.contentBlockerEngine =
            ContentBlockerEngineWrapper.createContentBlockerEngine(
                withJSON: json, logger: logger)
    }

    // Helper method to get the URL for advancedBlocking.json
    private static func getAdvancedBlockingURL(
        forGroupIdentifier identifier: String
    )
        -> URL
    {
        guard
            let url = FileManager.default
                .containerURL(
                    forSecurityApplicationGroupIdentifier: identifier)?
                .appending(
                    path: "advancedBlocking.json",
                    directoryHint: URL.DirectoryHint.notDirectory
                )
        else {
            fatalError(
                "Could not construct URL for advancedBlocking.json")
        }
        return url
    }

    // Helper method to load and parse JSON from a file
    private static func loadJSON(fromURL url: URL, logger: Logger) -> String {
        logger.log("Attempting to read advancedBlocking.json")

        // Check if the file exists
        let fileExists = FileManager.default.fileExists(atPath: url.path)
        logger.log(
            "advancedBlocking.json exists at \(url.path, privacy: .public): \(fileExists, privacy: .public)"
        )

        // Get file attributes for debugging
        if let attributes = try? FileManager.default.attributesOfItem(
            atPath: url.path)
        {
            logger.log("File attributes: \(attributes, privacy: .public)")
        }

        guard fileExists else {
            logger.error(
                "Error: advancedBlocking.json does not exist at \(url.path, privacy: .public)"
            )

            return "[]"  // Fallback: empty rules
        }

        // Simplified file reading for debugging (bypassing potential String encoding issues)
        if let data = try? Data(contentsOf: url),
            let loadedJson = String(data: data, encoding: .utf8)
        {
            logger.debug("Successfully loaded advanced blocking rules")
            return loadedJson
        } else {
            logger.error("Failed to read or decode advancedBlocking.json")
            return "[]"  // Fallback to empty rules
        }
    }

    // Helper method to create the ContentBlockerEngine
    private static func createContentBlockerEngine(
        withJSON json: String, logger: Logger
    ) -> ContentBlockerEngine {
        do {
            logger.log("Attempting to create ContentBlockerEngine")
            let engine = try ContentBlockerEngine(json)
            logger.log("ContentBlockerEngine initialized successfully")
            return engine
        } catch {
            logger.error(
                "Failed to initialize content blocker: \(error.localizedDescription, privacy: .public)"
            )
            // Fallback to empty rules
            do {
                let engine = try ContentBlockerEngine("[]")
                logger.warning(
                    "ContentBlockerEngine initialized with empty rules as fallback"
                )
                return engine
            } catch {
                fatalError(
                    "Failed to initialize content blocker with empty rules: \(error.localizedDescription)"
                )
            }
        }
    }

    public func getData(url: URL) -> String? {
        // Ensure ContentBlockerEngine is initialized
        let engine = contentBlockerEngine

        logger.log(
            "Getting data for URL: \(url.absoluteString, privacy: .public)")

        do {
            let data = try engine.getData(url: url)
            logger.log(
                "Data returned from engine: \(data, privacy: .public)")
            return data
        } catch {
            logger.error(
                "Failed to get data for URL: \(url.absoluteString, privacy: .public) - Error: \(error.localizedDescription, privacy: .public)"
            )
            return nil
        }
    }
}

// WebShieldExtra/SafariExtensionHandler.swift
import ContentBlockerEngine
import SafariServices
import os

class SafariExtensionHandler: SFSafariExtensionHandler {
    private let logger = Logger(
        subsystem: "me.arjuna.WebShield",
        category: "ContentBlockerEngineWrapper")
    override func messageReceived(
        withName messageName: String, from page: SFSafariPage,
        userInfo: [String: Any]?
    ) {
        page.getPropertiesWithCompletionHandler { properties in
            self.logger.info(
                "The extension received a message (\(messageName, privacy: .public)) from a script injected into (\(String(describing: properties?.url), privacy: .public)) with userInfo (\(userInfo ?? [:], privacy: .public))"
            )
        }

        if messageName == "getAdvancedBlockingData" {
            guard let userInfo = userInfo,
                let urlString = userInfo["url"] as? String,
                let pageUrl = URL(string: urlString)
            else {
                logger.info("Invalid message or URL")
                return
            }

            // Test method call to trigger further initialization
            if let mainData = ContentBlockerEngineWrapper.shared.getData(
                url: pageUrl)
            {
                let data: [String: Any] = [
                    "url": urlString,
                    "data": mainData,
                    "verbose": true,
                ]
                logger.info("Data received: (\(mainData, privacy: .public))")

                page.dispatchMessageToScript(
                    withName: "advancedBlockingData", userInfo: data)
            } else {
                logger.error(
                    "Failed to get data for URL: \(pageUrl.absoluteString, privacy: .public)"
                )
            }
        }
    }

    override func toolbarItemClicked(in window: SFSafariWindow) {
        logger.log(level: .default, "The extension's toolbar item was clicked")
    }

    override func validateToolbarItem(
        in window: SFSafariWindow,
        validationHandler: @escaping ((Bool, String) -> Void)
    ) {
        validationHandler(true, "")
    }

    //    override func popoverViewController() -> SFSafariExtensionViewController {
    //        SafariExtensionViewController.shared
    //    }
}

// WebShieldExtra/SafariExtensionViewController.swift
import SafariServices
import os.log

final class SafariExtensionViewController: SFSafariExtensionViewController {

    static let shared: SafariExtensionViewController = {
        let shared = SafariExtensionViewController()
        shared.preferredContentSize = NSSize(width: 240, height: 150)
        return shared
    }()
}

