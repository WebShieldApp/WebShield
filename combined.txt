
// WebShieldApp/Model/ContentBlocker/ContentBlockerState.swift
//
//  ContentBlockerState.swift
//  WebShieldApp
//
//

import Foundation
import SafariServices

actor ContentBlockerState: ObservableObject {
    private let identifier = "me.arjuna.WebShield.ContentBlocker"

    func reloadContentBlocker() async {
        do {
            try await SFContentBlockerManager.reloadContentBlocker(
                withIdentifier: identifier)
            print("Content blocker reloaded successfully")
        } catch {
            await handleReloadError(error)
        }
    }

    private func handleReloadError(_ error: Error) async {
        let nsError = error as NSError
        print("ERROR: Failed to reload content blocker")
        print("Error description: \(nsError.localizedDescription)")
        print("Error domain: \(nsError.domain)")
        print("Error code: \(nsError.code)")

        if let underlyingError = nsError.userInfo[NSUnderlyingErrorKey]
            as? NSError
        {
            print("Underlying error: \(underlyingError)")
        }

        print("User Info:")
        for (key, value) in nsError.userInfo {
            print("  \(key): \(value)")
        }

        if nsError.domain == "SFErrorDomain" {
            await handleSFErrorDomain(code: nsError.code)
        }
    }

    private func handleSFErrorDomain(code: Int) async {
        switch code {
        case 1:
            print(
                "SFErrorDomain error 1: Content Blocker not found or not owned by you."
            )
            print("Bundle Identifier: \(self.identifier)")
            print(
                "Please check JSON validity and file size (max 2MB, 50,000 rules)."
            )
        case 2:
            print("SFErrorDomain error 2: NSExtensionItem missing attachment.")
        case 3:
            print(
                "SFErrorDomain error 3: Error loading content blocker extension."
            )
        default:
            print("Unknown SFErrorDomain error code: \(code)")
        }
    }
}

// WebShieldApp/Model/Extension/ColorExtension.swift
//
//  ColorExtension.swift
//  WebShield
//
//  Created by Arjun on 2024-10-10.
//

import SwiftUI

extension Color {

    #if os(macOS)
        static let background = Color(NSColor.windowBackgroundColor)
        static let secondaryBackground = Color(NSColor.underPageBackgroundColor)
        static let tertiaryBackground = Color(NSColor.controlBackgroundColor)
    #else
        static let background = Color(UIColor.systemBackground)
        static let secondaryBackground = Color(
            UIColor.secondarySystemBackground)
        static let tertiaryBackground = Color(UIColor.tertiarySystemBackground)
    #endif
}

// WebShieldApp/Model/Extension/EditMode.swift
//
//  EditMode.swift
//  WebShield
//
//  Created by Arjun on 2024-10-11.
//

// Documentation comments are copied from the official documentation for iOS.

import SwiftUI

#if os(macOS)

    /// Reimplemenation of [EditMode](https://developer.apple.com/documentation/swiftui/editmode) for macOS.
    public enum EditMode {

        /// The user can edit the view content.
        case active

        /// The user canâ€™t edit the view content.
        case inactive

        /// The view is in a temporary edit mode.
        case transient
    }

    extension EditMode: Equatable {}
    extension EditMode: Hashable {}

    extension EditMode {

        /// Indicates whether a view is being edited.
        ///
        /// This property returns `true` if the mode is something other than inactive.
        public var isEditing: Bool {
            self != .inactive
        }
    }

    private struct EditModeEnvironmentKey: @preconcurrency EnvironmentKey {
        @MainActor static var defaultValue: Binding<EditMode>?
    }

    extension EnvironmentValues {

        /// An indication of whether the user can edit the contents of a view associated with this environment.
        public var editMode: Binding<EditMode>? {
            get {
                self[EditModeEnvironmentKey.self]
            }
            set {
                self[EditModeEnvironmentKey.self] = newValue
            }
        }
    }

#endif

// Below extension also don't exist on iOS, so keep them outside of the compiler directive block.

extension EditMode {

    /// Toggles the edit mode between `.inactive` and `.active`.
    public mutating func toggle() {
        switch self {
        case .inactive: self = .active
        case .active: self = .inactive
        case .transient: break
        #if os(iOS)
            @unknown default: break
        #endif
        }
    }
}

extension Optional where Wrapped == Binding<EditMode> {

    /// Convenience property so call sites can use a clean `editMode.isEditing` instead of the
    /// ugly boilerplate `editMode?.wrappedValue.isEditing == true`.
    public var isEditing: Bool {
        self?.wrappedValue.isEditing == true
    }
}

// WebShieldApp/Model/Extension/UserDefaultsExtension.swift
//
//  UserDefaultsExtension.swift
//  WebShield
//
//  Created by Arjun on 2024-07-19.
//

import Foundation

extension UserDefaults {
    static func exists(key: String) -> Bool {
        return UserDefaults.standard.object(forKey: key) != nil
    }
}

// WebShieldApp/Model/FilterList/FilterList.swift
import Foundation
import SwiftUI

final class FilterList: Identifiable, ObservableObject, Equatable, Codable {
    let id: String
    @Published var name: String
    let url: URL
    let category: FilterListCategory
    @Published var isSelected: Bool
    @Published var desc: String
    @Published var version: String?
    let isAdGuardAnnoyancesList: Bool
    @Published var children: [FilterList]?
    @Published var isExpanded: Bool
    @Published var isChild: Bool

    // Designated initializer
    init(
        id: String = UUID().uuidString,
        name: String,
        url: URL,
        category: FilterListCategory,
        isSelected: Bool = false,
        description: String = "Description not available.",
        version: String? = nil,
        isAdGuardAnnoyancesList: Bool = false,
        children: [FilterList]? = nil,
        isExpanded: Bool = false,
        isChild: Bool = false
    ) {
        self.id = id
        self.name = name
        self.url = url
        self.category = category
        self.isSelected = isSelected
        self.desc = description
        self.version = version
        self.isAdGuardAnnoyancesList = isAdGuardAnnoyancesList
        self.children = children
        self.isExpanded = isExpanded
        self.isChild = isChild
    }

    // Make 'init(from decoder:)' a designated initializer
    required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(String.self, forKey: .id)
        name = try container.decode(String.self, forKey: .name)
        url = try container.decode(URL.self, forKey: .url)
        category = try container.decode(
            FilterListCategory.self, forKey: .category)
        isSelected = try container.decode(Bool.self, forKey: .isSelected)
        desc = try container.decode(String.self, forKey: .desc)
        version = try container.decodeIfPresent(String.self, forKey: .version)
        isAdGuardAnnoyancesList = try container.decode(
            Bool.self, forKey: .isAdGuardAnnoyancesList)
        children = try container.decodeIfPresent(
            [FilterList].self, forKey: .children)
        isExpanded =
            try container.decodeIfPresent(Bool.self, forKey: .isExpanded)
            ?? false
        isChild =
            try container.decodeIfPresent(Bool.self, forKey: .isChild) ?? false
    }

    // Equatable conformance
    static func == (lhs: FilterList, rhs: FilterList) -> Bool {
        lhs === rhs
    }

    // Codable conformance
    enum CodingKeys: String, CodingKey {
        case id, name, url, category, isSelected, desc, version,
            isAdGuardAnnoyancesList, children, isExpanded, isChild
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(name, forKey: .name)
        try container.encode(url, forKey: .url)
        try container.encode(category, forKey: .category)
        try container.encode(isSelected, forKey: .isSelected)
        try container.encode(desc, forKey: .desc)
        try container.encodeIfPresent(version, forKey: .version)
        try container.encode(
            isAdGuardAnnoyancesList, forKey: .isAdGuardAnnoyancesList)
        try container.encodeIfPresent(children, forKey: .children)
        try container.encode(isExpanded, forKey: .isExpanded)
        try container.encode(isChild, forKey: .isChild)
    }

    // Additional methods
    func updateChildrenSelection(isSelected: Bool) {
        children?.forEach { child in
            if child.isSelected != isSelected {
                child.isSelected = isSelected
                child.updateChildrenSelection(isSelected: isSelected)
            }
        }
    }

    func updateSelectionBasedOnChildren() {
        guard let children = children else { return }
        let allSelected = children.allSatisfy { $0.isSelected }
        let noneSelected = children.allSatisfy { !$0.isSelected }

        if allSelected {
            if !isSelected {
                isSelected = true
            }
        } else if noneSelected {
            if isSelected {
                isSelected = false
            }
        } else {
            // Partially selected (if you want to handle this case)
            if isSelected {
                isSelected = false
            }
        }
    }
}

// WebShieldApp/Model/FilterList/FilterListCategory.swift
//
//  FilterListCategory.swift
//  WebShieldApp
//

import SwiftUI

// Add Codable conformance
enum FilterListCategory: String, CaseIterable, Identifiable, Codable {
    case all = "All"
    case ads = "Ads"
    case privacy = "Privacy"
    case security = "Security"
    case multipurpose = "Multipurpose"
    case cookies = "Cookies"
    case social = "Social"
    case annoyances = "Annoyances"
    case regional = "Regional"
    case experimental = "Experimental"
    case custom = "Custom"

    var id: String { self.rawValue }

    var systemImage: String {
        switch self {
        case .all: return "square.grid.2x2"
        case .ads: return "megaphone"
        case .privacy: return "hand.raised"
        case .security: return "lock"
        case .multipurpose: return "square.stack.3d.down.right"
        case .cookies: return "circle.dotted.circle"
        case .social: return "bubble.left.and.bubble.right"
        case .annoyances: return "exclamationmark.triangle"
        case .regional: return "globe"
        case .experimental: return "flask"
        case .custom: return "slider.horizontal.3"
        }
    }
}

// WebShieldApp/Model/FilterList/FilterListError.swift
//
//  FilterListError.swift
//  WebShield
//
//  Created by Arjun on 2024-07-16.
//

enum FilterListError: Error {
    case invalidData
    case containerNotFound
}

// WebShieldApp/Model/FilterList/FilterListManager.swift
//
//  FilterListManager.swift
//  WebShieldApp
//

import Combine
@preconcurrency import ContentBlockerConverter
import Foundation
import SafariServices

@MainActor
final class FilterListManager: ObservableObject {
    @Published private(set) var filterLists: [FilterList] = []
    @Published private(set) var isUpdating = false
    @Published var progress: Double = 0.0

    private let contentBlockerState: ContentBlockerState
    private let fileManager: FileManager
    let urlSession: URLSession
    private var totalStats: TotalStats = .init()

    private let customFilterListsKey = "customFilterLists"
    private var customFilterLists: [FilterList] = []
    @Published var hasUnsavedChanges: Bool = false
    private var initialSelectedStates: [UUID: Bool] = [:]

    // Add this to hold subscriptions
    private var cancellables = Set<AnyCancellable>()

    init(
        fileManager: FileManager = .default,
        urlSession: URLSession = .shared
    ) {
        self.contentBlockerState = ContentBlockerState()
        self.fileManager = fileManager
        self.urlSession = urlSession

        checkAndCreateGroupFolder()
        loadFilterLists()

        loadSelectedState()
        checkAndCreateBlockerList()
        Logger.clearLogs()

        // Initialize initialSelectedStates
        for filterList in filterLists {
            initialSelectedStates[UUID(uuidString: filterList.id)!] =
                filterList.isSelected
        }
    }

    private func checkSelectedStateForAnyFilter() -> Bool {
        return filterLists.contains {
            UserDefaults.exists(key: "filter_\($0.name)")
        }
    }

    // Load custom filter lists from UserDefaults
    private func loadCustomFilterLists() {
        guard
            let data = UserDefaults.standard.data(forKey: customFilterListsKey),
            let decoded = try? JSONDecoder().decode(
                [FilterList].self, from: data)
        else {
            return
        }
        customFilterLists = decoded
        filterLists.append(contentsOf: customFilterLists)
    }

    // Save custom filter lists to UserDefaults
    private func saveCustomFilterLists() {
        if let encoded = try? JSONEncoder().encode(customFilterLists) {
            UserDefaults.standard.set(encoded, forKey: customFilterListsKey)
        }
    }

    func removeCustomFilterList(_ filterList: FilterList) {
        guard filterList.category == .custom else { return }
        if let index = filterLists.firstIndex(of: filterList) {
            filterLists.remove(at: index)
        }
        if let customIndex = customFilterLists.firstIndex(of: filterList) {
            customFilterLists.remove(at: customIndex)
        }
        saveCustomFilterLists()
    }

    // Add new custom filter lists
    func addCustomFilterLists(urls: [URL]) {
        for url in urls {
            let name = url.lastPathComponent
            let newFilterList = FilterList(
                name: name,
                url: url,
                category: .custom,
                isSelected: true,
                description: "Custom filter list imported by user.",
                isAdGuardAnnoyancesList: false
            )
            customFilterLists.append(newFilterList)
            filterLists.append(newFilterList)
        }
        saveCustomFilterLists()
    }

    // Move Custom Filter List
    func moveCustomFilterList(fromOffsets: IndexSet, toOffset: Int) {
        guard fromOffsets.first != nil else { return }
        let originalIndex = fromOffsets.first!
        let destinationIndex = toOffset
        if originalIndex < destinationIndex {
            filterLists.move(
                fromOffsets: fromOffsets, toOffset: destinationIndex - 1)
        } else {
            filterLists.move(
                fromOffsets: fromOffsets, toOffset: destinationIndex)
        }
        // Update customFilterLists accordingly if needed
        saveCustomFilterLists()
    }

    // Remove Custom Filter List
    func removeCustomFilterList(
        at offsets: IndexSet, in category: FilterListCategory
    ) {
        guard category == .custom else { return }
        let customIndices = filterLists.enumerated().filter {
            $0.element.category == .custom
        }.map { $0.offset }
        let indicesToRemove = offsets.map { customIndices[$0] }
        for index in indicesToRemove.sorted(by: >) {  // Remove from highest to lowest to prevent index shifting
            let filterList = filterLists[index]
            if let customIndex = customFilterLists.firstIndex(of: filterList) {
                customFilterLists.remove(at: customIndex)
            }
            filterLists.remove(at: index)
        }
        saveCustomFilterLists()
    }

    private func checkAndCreateBlockerList() {
        guard let containerURL = GroupContainerURL.groupContainerURL() else {
            Logger.logMessage("Error: Unable to access shared container")
            return
        }
        let fileURL = containerURL.appendingPathComponent("blockerList.json")

        if fileManager.fileExists(atPath: fileURL.path) {
            Logger.logMessage(
                "blockerList.json already exists at \(fileURL.path)")
            return
        }

        do {
            // Create an empty JSON array and write to the file
            let emptyArray: [[String: Any]] = []
            let data = try JSONSerialization.data(
                withJSONObject: emptyArray, options: [])
            try data.write(to: fileURL, options: .atomic)
            Logger.logMessage(
                "Created empty blockerList.json at \(fileURL.path)")
        } catch {
            Logger.logMessage(
                "Error creating blockerList.json: \(error.localizedDescription)"
            )
        }
    }

    private func checkAndCreateGroupFolder() {
        guard let containerURL = GroupContainerURL.groupContainerURL() else {
            Logger.logMessage("Error: Unable to access shared container")
            return
        }

        if FileManager.default.fileExists(atPath: containerURL.path) {
            Logger.logMessage(
                "Group folder already exists: \(containerURL.path)")
            return
        }

        do {
            try FileManager.default.createDirectory(
                at: containerURL, withIntermediateDirectories: true)
            Logger.logMessage("Created group folder: \(containerURL.path)")
        } catch {
            Logger.logMessage(
                "Error creating group folder: \(error.localizedDescription)")
        }
    }

    private func loadSelectedState() {
        if checkSelectedStateForAnyFilter() {
            let defaults = UserDefaults.standard
            for index in filterLists.indices {
                filterLists[index].isSelected = defaults.bool(
                    forKey: "filter_\(filterLists[index].name)")
            }
        }
    }

    private func saveSelectedState(filter: FilterList) {
        UserDefaults.standard.set(
            filter.isSelected, forKey: "filter_\(filter.name)")
    }

    private func saveLastUpdateDate(filter: FilterList) {
        UserDefaults.standard.set(
            Date(), forKey: "lastUpdateDate_\(filter.name)")
    }

    // Get Last Update Date
    func getLastUpdateDate(filter: FilterList) -> String {
        let defaults = UserDefaults.standard
        guard
            let date = defaults.object(forKey: "lastUpdateDate_\(filter.name)")
                as? Date
        else {
            return "Never Updated!"
        }
        let df = DateFormatter()
        df.dateStyle = .short
        return df.string(from: date)
    }

    func isSelected(_ filterList: FilterList) -> Bool {
        return filterLists.first { $0.id == filterList.id }?.isSelected ?? false
    }

    // Set Selection for Filter List
    func setSelection(for filterList: FilterList, isSelected: Bool) {
        if let index = filterLists.firstIndex(where: { $0.id == filterList.id })
        {
            filterLists[index].isSelected = isSelected
            objectWillChange.send()
        }
    }

    nonisolated func processFilterLists(
        selectedLists: [FilterListData],
        urlSession: URLSession
    ) async -> [(ConversionResult, String)] {
        var results = [(ConversionResult, String)]()
        let processor = FilterListProcessor(urlSession: urlSession)
        await withTaskGroup(of: (ConversionResult, String).self) { group in
            for listData in selectedLists {
                let listURL = listData.urlString
                let listName = listData.name
                group.addTask {
                    do {
                        guard let url = URL(string: listURL) else {
                            throw URLError(.badURL)
                        }
                        let data = try await processor.downloadFilterList(
                            from: url, name: listName)
                        let parsed = try processor.parseRules(data)
                        let converted =
                            try await processor.convertToAdGuardFormat(parsed)
                        return (converted, listData.id)
                    } catch {
                        // Log error on main actor
                        await MainActor.run {
                            Logger.logMessage(
                                "Error processing filter list: \(error)")
                        }
                        return (
                            ConversionResult(
                                entries: [],
                                limit: 0,
                                errorsCount: 0,
                                message: ""
                            ), UUID().uuidString
                        )
                    }
                }
            }

            // Collect results from the task group
            for await result in group {
                results.append(result)
            }
        }
        return results
    }

    @MainActor
    func applyChanges() async {
        let selectedLists = filterLists.filter { $0.isSelected }
        // Convert to FilterListData array to ensure Sendable
        let selectedListData = selectedLists.map { filterList in
            FilterListData(
                name: filterList.name,
                urlString: filterList.url.absoluteString,
                category: filterList.category,
                isSelected: filterList.isSelected,
                description: filterList.desc,
                isAdGuardAnnoyancesList: filterList.isAdGuardAnnoyancesList
            )
        }
        var allRules: [[String: Any]] = []
        totalStats = .init()  // Reset total stats

        progress = 0
        let totalLists = selectedLists.count
        var processedLists = 0

        // Run processFilterLists() in a detached task
        let results = await Task.detached {
            () -> [(ConversionResult, String)] in
            await self.processFilterLists(
                selectedLists: selectedListData, urlSession: self.urlSession)
        }.value

        Logger.logMessage("Number of results received: \(results.count)")

        // Process results on the main actor
        for (converted, listID) in results {
            if let newRules = try? JSONSerialization.jsonObject(
                with: Data(converted.converted.utf8), options: []
            ) as? [[String: Any]] {
                allRules.append(contentsOf: newRules)
            }

            // Save last update date
            if let list = self.filterLists.first(where: { $0.id == listID }) {
                self.saveLastUpdateDate(filter: list)
            }

            self.updateTotalStats(with: converted)
            self.logMessageConversionStatistics(converted)

            // Update progress
            processedLists += 1
            self.progress = Double(processedLists) / Double(totalLists)
        }

        Logger.logMessage("Total rules collected: \(allRules.count)")

        do {
            try await writeAllRulesToFile(allRules)
            await reloadContentBlocker()
            logMessageTotalConversionStatistics()
        } catch {
            Logger.logMessage("Error writing rules to file: \(error)")
        }

        // Save selected state
        for list in filterLists {
            saveSelectedState(filter: list)
        }
        // Reset progress
        progress = 1.0
    }

    private func getDocumentsDirectory() -> URL {
        FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[
            0]
    }

    func saveFilterLists() {
        do {
            let data = try JSONEncoder().encode(filterLists)
            let url = getDocumentsDirectory().appendingPathComponent(
                "filterLists.json")
            try data.write(to: url)
        } catch {
            print("Error saving filter lists: \(error)")
        }
    }

    func loadFilterLists() {
        let url = getDocumentsDirectory().appendingPathComponent(
            "filterLists.json")
        if FileManager.default.fileExists(atPath: url.path) {
            do {
                let data = try Data(contentsOf: url)
                filterLists = try JSONDecoder().decode(
                    [FilterList].self, from: data)
            } catch {
                print("Error loading filter lists: \(error)")
                loadDefaultFilterLists()
            }
        } else {
            loadDefaultFilterLists()
        }
    }

    private func updateTotalStats(with result: ConversionResult) {
        totalStats.totalConvertedCount += result.totalConvertedCount
        totalStats.convertedCount += result.convertedCount
        totalStats.errorsCount += result.errorsCount
        totalStats.overLimit += result.overLimit ? 1 : 0
    }

    private func writeAllRulesToFile(_ rules: [[String: Any]]) async throws {
        guard
            let containerURL = GroupContainerURL.groupContainerURL()
        else {
            throw FilterListError.containerNotFound
        }

        let fileURL = containerURL.appending(path: "blockerList.json")
        Logger
            .logMessage(
                "Writing to blockerList.json at \(fileURL.absoluteString)"
            )
        let data = try JSONSerialization.data(
            withJSONObject: rules, options: .prettyPrinted)
        try data.write(to: fileURL, options: .atomic)

        let attributes = try fileManager.attributesOfItem(atPath: fileURL.path)
        if let fileSize = attributes[.size] as? Int64, fileSize > 2_000_000 {
            Logger.logMessage(
                "WARNING: blockerList.json size (\(fileSize) bytes) exceeds 2MB limit for Safari content blockers!"
            )
        }
    }

    // Modify loadFilterLists to ensure shared instances
    private func loadDefaultFilterLists() {
        var filterListDict = [String: FilterList]()

        // First, create all FilterList instances without setting children
        for data in FilterListProvider.filterListData {
            let filterList = FilterList(
                name: data.name,
                url: URL(string: data.urlString)!,
                category: data.category,
                isSelected: data.isSelected,
                description: data.description,
                isAdGuardAnnoyancesList: data.isAdGuardAnnoyancesList
            )
            filterLists.append(filterList)
            filterListDict[data.name] = filterList
        }

        // Now, set up the hierarchy by assigning children
        for data in FilterListProvider.filterListData {
            if let childrenNames = data.childrenNames,
                let parentFilterList = filterListDict[data.name]
            {
                parentFilterList.children = childrenNames.compactMap {
                    childName in
                    if let child = filterListDict[childName] {
                        child.isChild = true  // Mark as child
                        return child
                    }
                    return nil
                }
            }
        }

        // Observe changes in isSelected
        for filterList in filterLists {
            filterList.objectWillChange
                .sink { [weak self] _ in
                    self?.checkForUnsavedChanges()
                    self?.objectWillChange.send()
                }
                .store(in: &cancellables)
        }

        // Load custom filter lists
        loadCustomFilterLists()
    }

    private func checkForUnsavedChanges() {
        for filterList in filterLists {
            if initialSelectedStates[UUID(uuidString: filterList.id)!]
                != filterList.isSelected
            {
                hasUnsavedChanges = true
                return
            }
        }
        hasUnsavedChanges = false
    }

    // Add a Set to hold AnyCancellable references
    //    private var cancellables = Set<AnyCancellable>()

    private func logMessageTotalConversionStatistics() {
        Logger.logMessage(
            """
            Total conversion statistics:
            - Total converted count: \(totalStats.totalConvertedCount)
            - Converted count: \(totalStats.convertedCount)
            - Errors count: \(totalStats.errorsCount)
            - Lists over limit: \(totalStats.overLimit)
            """)
    }

    private func logMessageConversionStatistics(_ result: ConversionResult) {
        Logger.logMessage(
            """
            Conversion statistics:
            - Total converted count: \(result.totalConvertedCount)
            - Converted count: \(result.convertedCount)
            - Errors count: \(result.errorsCount)
            - Over limit: \(result.overLimit)
            """)
    }

    private func reloadContentBlocker() async {
        await contentBlockerState.reloadContentBlocker()
    }

    func parseMetadata(from content: String) -> (
        title: String?, description: String?, version: String?
    ) {
        var title: String?
        var description: String?
        var version: String?

        let lines = content.components(separatedBy: .newlines)
        for line in lines {
            if line.hasPrefix("! Title:") {
                title = line.replacingOccurrences(of: "! Title:", with: "")
                    .trimmingCharacters(in: .whitespaces)
            } else if line.hasPrefix("! Description:") {
                description = line.replacingOccurrences(
                    of: "! Description:", with: ""
                ).trimmingCharacters(in: .whitespaces)
            } else if line.hasPrefix("! Version:") {
                version = line.replacingOccurrences(of: "! Version:", with: "")
                    .trimmingCharacters(in: .whitespaces)
            }

            if title != nil && description != nil && version != nil {
                break
            }
        }

        return (title, description, version)
    }

}

// WebShieldApp/Model/FilterList/FilterListProcessor.swift
//
//  FilterListProcessor.swift
//  WebShield
//
//  Created by Arjun on 2024-10-19.
//

import ContentBlockerConverter
import Foundation

struct FilterListProcessor {
    let urlSession: URLSession

    init(urlSession: URLSession = .shared) {
        self.urlSession = urlSession
    }

    func downloadFilterList(from url: URL, name: String) async throws -> Data {
        let (data, _) = try await urlSession.data(from: url)
        return data
    }

    func parseRules(_ data: Data) throws -> [String] {
        //        Logger.logMessage("Parsing rules...")
        guard let content = String(data: data, encoding: .utf8) else {
            throw FilterListError.invalidData
        }

        return content.components(separatedBy: .newlines)
            .filter { !$0.hasPrefix("!") && !$0.hasPrefix("[") && !$0.isEmpty }
            .map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }
    }

    func convertToAdGuardFormat(_ rules: [String]) async throws
        -> ConversionResult
    {
        //        Logger.logMessage("Converting to AdGuard format...")
        return ContentBlockerConverter().convertArray(
            rules: rules,
            safariVersion: .safari16_4,
            optimize: true,
            advancedBlocking: true,
            advancedBlockingFormat: .json
        )
    }
}

// WebShieldApp/Model/FilterList/FilterListProvider.swift
//
//  FilterListProvider.swift
//  WebShieldApp
//

import Foundation

enum FilterListProvider {
    static func filterLists(for category: FilterListCategory) -> [FilterList] {
        switch category {
        case .all: return allFilterLists
        case .ads: return allFilterLists.filter { $0.category == .ads }
        case .privacy: return allFilterLists.filter { $0.category == .privacy }
        case .security:
            return allFilterLists.filter { $0.category == .security }
        case .multipurpose:
            return allFilterLists.filter { $0.category == .multipurpose }
        case .cookies: return allFilterLists.filter { $0.category == .cookies }
        case .social: return allFilterLists.filter { $0.category == .social }
        case .annoyances:
            return allFilterLists.filter { $0.category == .annoyances }
        case .regional:
            return allFilterLists.filter { $0.category == .regional }
        case .experimental:
            return allFilterLists.filter { $0.category == .experimental }
        case .custom: return allFilterLists.filter { $0.category == .custom }
        }
    }
    static let filterListData: [FilterListData] = [
        FilterListData(
            name: "AdGuard Base filter (Optimized)",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/2_optimized.txt",
            category: .ads,
            isSelected: true,
            description:
                "EasyList + AdGuard English filter. This filter is necessary for quality ad blocking."
        ),
        FilterListData(
            name: "AdGuard Mobile Ads filter (Optimized)",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/11_optimized.txt",
            category: .ads,
            isSelected: false,
            description:
                "Filter for all known mobile ad networks. Useful for mobile devices."
        ),
        FilterListData(
            name: "EasyList (Optimized)",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/101_optimized.txt",
            category: .ads,
            isSelected: false,
            description:
                "EasyList is the primary subscription that removes adverts from web pages in English. Already included in AdGuard Base filter."
        ),
        FilterListData(
            name: "AdGuard Tracking Protection filter (Optimized)",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/3_optimized.txt",
            category: .privacy,
            isSelected: false,
            description:
                "The most comprehensive list of various online counters and web analytics tools. Use this filter if you do not want your actions on the Internet to be tracked."
        ),
        FilterListData(
            name: "EasyPrivacy (Optimized)",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/118_optimized.txt",
            category: .privacy,
            isSelected: false,
            description:
                "Privacy protection supplement for EasyList."
        ),
        FilterListData(
            name: "Online Malicious URL Blocklist (Optimized)",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/208_optimized.txt",
            category: .security,
            isSelected: false,
            description:
                "Blocks domains that are known to be used to propagate malware and spyware."
        ),
        FilterListData(
            name: "Phishing URL Blocklist (Optimized)",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/255_optimized.txt",
            category: .security,
            isSelected: false,
            description:
                "Phishing URL blocklist for uBlock Origin (uBO), AdGuard, Vivaldi, Pi-hole, Hosts file, Dnsmasq, BIND, Unbound, Snort and Suricata."
        ),
        FilterListData(
            name: "Peter Lowe's Blocklist (Optimized)",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/204_optimized.txt",
            category: .multipurpose,
            isSelected: false,
            description:
                "Filter that blocks ads, trackers, and other nasty things."
        ),
        FilterListData(
            name: "AdGuard Cookie Notices filter (Optimized)",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/18_optimized.txt",
            category: .cookies,
            isSelected: false,
            description:
                "Blocks cookie notices on web pages."
        ),
        FilterListData(
            name: "EasyList Cookie List (Optimized)",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/241_optimized.txt",
            category: .cookies,
            isSelected: false,
            description:
                "Removes cookie and privacy warnings. Already included in Fanboy's Annoyances list."
        ),
        FilterListData(
            name: "AdGuard Social Media filter (Optimized)",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/4_optimized.txt",
            category: .social,
            isSelected: false,
            description:
                "Filter for social media widgets such as 'Like' and 'Share' buttons and more."
        ),
        FilterListData(
            name: "Fanboy's Social Blocking List (Optimized)",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/123_optimized.txt",
            category: .social,
            isSelected: false,
            description:
                "Hides and blocks social content, social widgets, social scripts and social icons. Already included in Fanboy's Annoyances list."
        ),
        FilterListData(
            name: "Fanboy's Anti-Facebook List (Optimized)",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/225_optimized.txt",
            category: .social,
            isSelected: false,
            description:
                "Warning, it will break Facebook-based comments on some websites and may also break some Facebook apps or games."
        ),
        FilterListData(
            name: "AdGuard Annoyances filter (Optimized)",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/14_optimized.txt",
            category: .annoyances,
            isSelected: false,
            description:
                "Blocks irritating elements on web pages including cookie notices, third-party widgets and in-page pop-ups. Contains the following AdGuard filters: Cookie Notices, Popups, Mobile App Banners, Other Annoyances and Widgets.",
            isAdGuardAnnoyancesList: true,
            childrenNames: [
                "AdGuard Cookie Notices filter (Optimized)",
                "AdGuard Popups filter (Optimized)",
                "AdGuard Mobile App Banners filter (Optimized)",
                "AdGuard Other Annoyances filter (Optimized)",
                "AdGuard Widgets filter (Optimized)",
            ]
        ),
        FilterListData(
            name: "AdGuard Popups filter (Optimized)",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/19_optimized.txt",
            category: .annoyances,
            isSelected: false,
            description:
                "Blocks all kinds of pop-ups that are not necessary for websites' operation according to our Filter policy."
        ),
        FilterListData(
            name: "AdGuard Mobile App Banners filter (Optimized)",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/20_optimized.txt",
            category: .annoyances,
            isSelected: false,
            description:
                "Blocks all kinds of pop-ups that are not necessary for websites' operation according to our Filter policy."
        ),
        FilterListData(
            name: "AdGuard Other Annoyances filter (Optimized)",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/21_optimized.txt",
            category: .annoyances,
            isSelected: false,
            description:
                "Blocks irritating elements on web pages that do not fall under the popular categories of annoyances."
        ),
        FilterListData(
            name: "AdGuard Widgets filter (Optimized)",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/22_optimized.txt",
            category: .annoyances,
            isSelected: false,
            description:
                "Blocks annoying third-party widgets: online assistants, live support chats, etc."
        ),
        FilterListData(
            name: "Fanboy's Annoyances (Optimized)",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/122_optimized.txt",
            category: .annoyances,
            isSelected: false,
            description:
                "Removes in-page pop-ups and other annoyances. Includes Fanboy's Social Blocking & EasyList Cookie Lists."
        ),
        FilterListData(
            name: "AdGuard Russian filter (Optimized)",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/1_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Filter that enables ad blocking on websites in Russian language."
        ),
        FilterListData(
            name: "AdGuard German filter (Optimized)",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/6_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "EasyList Germany + AdGuard German filter. Filter list that specifically removes ads on websites in German language."
        ),
        FilterListData(
            name: "Adblock Warning Removal List (Optimized)",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/207_optimized.txt",
            category: .multipurpose,
            isSelected: false,
            description:
                "Removes anti-adblock warnings and other obtrusive messages."
        ),
        FilterListData(
            name: "AdGuard Experimental filter (Optimized)",
            urlString:
                "https://filters.adtidy.org/extension/safari/filters/5_optimized.txt",
            category: .experimental,
            isSelected: false,
            description:
                "Filter designed to test certain hazardous filtering rules before they are added to the basic filters."
        ),
    ]

    static var allFilterLists: [FilterList] {
        []
    }
}

struct FilterListData: Sendable {
    let name: String
    let urlString: String
    let category: FilterListCategory
    let isSelected: Bool
    let description: String
    let isAdGuardAnnoyancesList: Bool
    let childrenNames: [String]?  // For hierarchy
    let id: String

    init(
        name: String, urlString: String, category: FilterListCategory,
        isSelected: Bool, description: String,
        isAdGuardAnnoyancesList: Bool = false, childrenNames: [String]? = nil
    ) {
        self.name = name
        self.urlString = urlString
        self.category = category
        self.isSelected = isSelected
        self.description = description
        self.isAdGuardAnnoyancesList = isAdGuardAnnoyancesList
        self.childrenNames = childrenNames
        self.id = UUID().uuidString
    }
}

// WebShieldApp/Model/FilterList/FilterListSection.swift
//
//  FilterListSection.swift
//  WebShield
//
//  Created by Arjun on 2024-07-16.
//

import Foundation

struct FilterListSection: Identifiable {
    let id = UUID()
    let title: String
    let filterLists: [FilterList]
}

// WebShieldApp/Model/FilterList/TotalStats.swift
//
//  TotalStats.swift
//  WebShield
//
//  Created by Arjun on 2024-07-30.
//

struct TotalStats {
    var totalConvertedCount: Int = 0
    var convertedCount: Int = 0
    var errorsCount: Int = 0
    var overLimit: Int = 0
}

// WebShieldApp/Model/GroupContainerURL.swift
//
//  GroupContainerURL.swift
//  WebShieldApp
//
//  Created by Arjun on 2024-09-08.
//

import Foundation

@MainActor
struct GroupContainerURL {
    private static let fileManager: FileManager = FileManager.default
    static func groupContainerURL() -> URL? {
        return fileManager.containerURL(
            forSecurityApplicationGroupIdentifier:
                Identifiers.groupID)
    }
}

// WebShieldApp/Model/Identifiers.swift
//
//  GlobalSettings.swift
//  WebShieldApp
//
//  Created by Arjun on 2024-09-08.
//

import Foundation

public enum Identifiers {
    static let groupID: String = "G5S45S77DF.me.arjuna.WebShield"
}

// WebShieldApp/Model/Item.swift
import Foundation
import SwiftData

@Model final class Item {
    var timestamp: Date

    init(timestamp: Date) {
        self.timestamp = timestamp
    }
}

// WebShieldApp/Model/Logger.swift
//
//  Logger.swift
//  WebShieldApp
//
//  Created by Arjun on 2024-09-08.
//

import Foundation

@MainActor
class Logger {
    static var logs: String = ""
    static func logMessage(_ message: String) {
        print(message)
        Logger.logs += message + "\n"
        writeLogsToFile()
    }

    private static func writeLogsToFile() {
        guard
            let containerURL = GroupContainerURL.groupContainerURL()
        else { return }
        let fileURL = containerURL.appendingPathComponent("logs.txt")

        do {
            try Logger.logs.write(to: fileURL, atomically: true, encoding: .utf8)
        } catch {
            Logger.logMessage("Error saving logs: \(error)")
        }
    }

    func readLogsFromFile() {
        guard
            let containerURL = GroupContainerURL.groupContainerURL()
        else { return }
        let fileURL = containerURL.appendingPathComponent("logs.txt")
        do {
            Logger.logs = try String(contentsOf: fileURL, encoding: .utf8)
        } catch {
            Logger.logMessage("Error loading logs: \(error)")
        }
    }

    static func clearLogs() {
        Logger.logs = ""
        Logger.writeLogsToFile()
    }

}

// WebShieldApp/View/ContentView.swift
//
//  ContentView.swift
//  WebShieldApp
//

import SwiftUI

struct ContentView: View {
    @State private var selectedCategory: FilterListCategory? = .all
    @StateObject private var filterListManager = FilterListManager()

    var body: some View {
        NavigationSplitView {
            SidebarView()
                .environmentObject(filterListManager)
        } detail: {
            DetailView(selectedCategory: selectedCategory)
                .environmentObject(filterListManager)
        }
    }
}

// WebShieldApp/View/FilterList/FilterListToggle.swift
//
//  FilterListToggle.swift
//  WebShieldApp
//

import SwiftUI

struct FilterListToggle: View {
    @EnvironmentObject var filterListManager: FilterListManager
    @ObservedObject var filterList: FilterList
    let deleteAction: (() -> Void)?

    init(filterList: FilterList, deleteAction: (() -> Void)? = nil) {
        self.filterList = filterList
        self.deleteAction = deleteAction
    }

    var body: some View {
        if let children = filterList.children, !children.isEmpty {
            DisclosureGroup(isExpanded: $filterList.isExpanded) {
                ForEach(children) { child in
                    FilterListToggle(filterList: child)
                        .padding(.leading)
                        .onChange(of: child.isSelected) {
                            filterList.updateSelectionBasedOnChildren()
                        }
                }
            } label: {
                Toggle(
                    isOn: Binding(
                        get: { filterList.isSelected },
                        set: { newValue in
                            filterList.isSelected = newValue
                            filterList.updateChildrenSelection(
                                isSelected: newValue)
                        }
                    )
                ) {
                    VStack(alignment: .leading) {
                        Text(filterList.name)
                            .font(.headline)
                            .foregroundColor(.primary)
                        if let version = filterList.version {
                            Text("Version: \(version)")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        Text(filterList.desc)
                            .font(.caption2)
                            .foregroundColor(.secondary)
                        Text(
                            "Last Updated: \(filterListManager.getLastUpdateDate(filter: filterList))"
                        )
                        .font(.caption)
                        .foregroundColor(.secondary)
                    }
                }
            }
        } else {
            HStack {
                Toggle(isOn: $filterList.isSelected) {
                    VStack(alignment: .leading) {
                        Text(filterList.name)
                            .font(.headline)
                            .foregroundColor(.primary)
                        if let version = filterList.version {
                            Text("Version: \(version)")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        Text(filterList.desc)
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
            }
            .contextMenu {
                if filterList.category == .custom {
                    Button(role: .destructive) {
                        deleteAction?()
                    } label: {
                        Label("Delete", systemImage: "trash")
                    }
                }
            }
        }
    }
}

// WebShieldApp/View/FilterList/FilterListView.swift
//
//  FilterListView.swift
//  WebShieldApp
//

import SwiftUI

struct FilterListView: View {
    let category: FilterListCategory
    @EnvironmentObject private var filterListManager: FilterListManager
    @State private var showingLogs = false
    @State private var showingImport = false
    @State private var isUpdating = false
    @Environment(\.editMode) private var editMode

    // State variable for animation
    @State private var pulsate = false

    var body: some View {
        VStack {
            if isUpdating {
                ProgressView(value: filterListManager.progress)
                    .progressViewStyle(LinearProgressViewStyle())
                    .padding()
            }

            List {
                if category == .all {
                    ForEach(FilterListCategory.allCases.dropFirst(), id: \.self)
                    { category in
                        Section(header: Text(category.rawValue)) {
                            ForEach(filterListsForCategory(category)) {
                                filterList in
                                FilterListToggle(filterList: filterList) {
                                    filterListManager.removeCustomFilterList(
                                        filterList)
                                }
                            }
                        }
                    }
                } else {
                    Section(header: Text(category.rawValue)) {
                        ForEach(filterListsForCategory(category)) {
                            filterList in
                            FilterListToggle(filterList: filterList) {
                                filterListManager.removeCustomFilterList(
                                    filterList)
                            }
                        }
                        .onDelete(perform: deleteCustomFilterLists)
                        .onMove(perform: moveCustomFilterLists)
                    }
                }
            }
            .listStyle(.automatic)
        }
        .toolbar {
            ToolbarItemGroup(placement: .automatic) {
                Button(action: {
                    showingLogs = true
                }) {
                    Image(systemName: "doc.text.magnifyingglass")
                        .imageScale(.large)
                }
                .help("Show Logs")

                if isUpdating {
                    ProgressView().scaledToFit()
                } else {
                    Button(action: {
                        Task {
                            isUpdating = true
                            await filterListManager.applyChanges()
                            isUpdating = false
                        }
                    }) {
                        Image(systemName: "arrow.clockwise")
                            .imageScale(.large)
                    }
                    .help("Refresh All Filters")
                }

                Button(action: {
                    showingImport.toggle()
                }) {
                    Image(systemName: "plus")
                        .imageScale(.large)
                }
                .help("Import Filters")
            }
        }
        .sheet(isPresented: $showingLogs) {
            LogsView(logs: Logger.logs)
        }
        .sheet(isPresented: $showingImport) {
            ImportView()
                .environmentObject(filterListManager)
        }
    }
    private func deleteCustomFilterLists(at offsets: IndexSet) {
        filterListManager.removeCustomFilterList(at: offsets, in: category)
    }

    private func moveCustomFilterLists(
        from source: IndexSet, to destination: Int
    ) {
        filterListManager.moveCustomFilterList(
            fromOffsets: source, toOffset: destination)
    }

    private func filterListsForCategory(_ category: FilterListCategory)
        -> [FilterList]
    {
        filterListManager.filterLists.filter {
            $0.category == category && !$0.isChild
        }
    }
}

// WebShieldApp/View/Navbar/CategoryNav.swift
//
//  CategoryNav.swift
//  WebShield
//
//  Created by Arjun on 2024-07-16.
//
import Foundation
import SwiftUI

struct CategoryNav: View {
    let category: FilterListCategory

    var body: some View {
        NavigationLink(destination: FilterListView(category: category)) {
            Label {
                Text(category.rawValue)
            } icon: {
                Image(systemName: category.systemImage)
            }
        }
    }
}

// WebShieldApp/View/Navbar/DetailView.swift
//
//  DetailView.swift
//  WebShieldApp
//


import SwiftUI

struct DetailView: View {

    @EnvironmentObject private var filterListManager: FilterListManager
    let selectedCategory: FilterListCategory?

    var body: some View {
        NavigationStack {
            if let category = selectedCategory {
                FilterListView(category: category).environmentObject(
                    filterListManager)
            } else {
                Text("Select a category")
            }
        }.environmentObject(filterListManager)
    }
}

// WebShieldApp/View/Navbar/SidebarView.swift
//
//  SidebarView.swift
//  WebShieldApp
//


import SwiftUI

struct SidebarView: View {
    //    @Binding var selectedCategory: FilterListCategory?

    var body: some View {
        List {
            CategoryNav(category: .all)
            CategoryNav(category: .regional)
            CategoryNav(category: .custom)
        }
        .listStyle(SidebarListStyle())
    }
}

// WebShieldApp/View/Navbar/Toolbar/ImportView.swift
//
//  ImportView.swift
//  WebShieldApp
//
//  Created by Arjun on 2024-09-08.
//

import Foundation
import SwiftUI

struct ImportView: View {
    @Environment(\.dismiss) var dismiss
    @EnvironmentObject private var filterListManager: FilterListManager
    @State private var urlsText: String = ""
    @State private var showingAlert = false
    @State private var alertMessage = ""

    var body: some View {
        VStack(spacing: 16) {
            Text("Import Filters")
                .font(.largeTitle)
                .padding(.top)

            Text("Enter one URL per line:")
                .font(.headline)

            ScrollView {
                TextEditor(text: $urlsText)
                    .frame(minHeight: 150)
                    .padding()
                    .overlay(
                        RoundedRectangle(cornerRadius: 8)
                            .stroke(Color.secondary, lineWidth: 1)
                    )
                    .padding([.leading, .trailing])
            }

            if !alertMessage.isEmpty {
                Text(alertMessage)
                    .foregroundColor(.red)
                    .font(.caption)
                    .padding()
            }

            Spacer()

            HStack {
                Button("Cancel") {
                    dismiss()
                }
                .keyboardShortcut(.cancelAction)

                Spacer()

                Button("Import") {
                    importFilterLists()
                }
                .disabled(
                    urlsText.trimmingCharacters(in: .whitespacesAndNewlines)
                        .isEmpty
                )
                .keyboardShortcut(.defaultAction)
            }
            .padding()
        }
        .padding()
        .frame(minWidth: 400, minHeight: 300)
        .alert("Import Results", isPresented: $showingAlert) {
            Button("OK", role: .cancel) {}
        } message: {
            Text(alertMessage)
        }
    }
    private func importFilterLists() {
        let lines =
            urlsText
            .components(separatedBy: .newlines)
            .map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }
            .filter { !$0.isEmpty }

        var validURLs: [URL] = []
        var invalidURLs: [String] = []

        for line in lines {
            if let url = URL(string: line),
                url.scheme == "http" || url.scheme == "https"
            {
                validURLs.append(url)
            } else {
                invalidURLs.append(line)
            }
        }

        if !validURLs.isEmpty {
            filterListManager.addCustomFilterLists(urls: validURLs)
        }

        if !invalidURLs.isEmpty {
            alertMessage =
                "Some URLs were invalid and were not imported:\n"
                + invalidURLs.joined(separator: "\n")
        } else {
            alertMessage = "All URLs imported successfully!"
        }

        showingAlert = true
        dismiss()
    }
}

// WebShieldApp/View/Navbar/Toolbar/LogsView.swift
import SwiftUI

struct LogsView: View {
    let logs: String
    @Environment(\.dismiss) var dismiss
    @State private var searchText = ""
    @State private var showCopyAlert = false

    var body: some View {
        #if os(iOS) || os(tvOS) || os(visionOS)
            NavigationView {
                content
                    .navigationTitle("Logs")
                    .navigationBarTitleDisplayMode(.inline)
                    .toolbar {
                        // Close button
                        ToolbarItem(placement: .navigationBarLeading) {
                            Button("Close") {
                                dismiss()
                            }
                        }
                        // Copy button
                        if hasLogs {
                            ToolbarItem(placement: .navigationBarTrailing) {
                                Button(action: {
                                    copyLogsToClipboard()
                                }) {
                                    Image(systemName: "doc.on.doc")
                                }
                            }
                        }
                    }
            }
            .navigationViewStyle(StackNavigationViewStyle())
        #endif
        //        #else
        //            VStack {
        //                content
        //                HStack {
        //                    Spacer()
        //                    Button("Close") {
        //                        dismiss()
        //                    }
        //                    .padding()
        //                }
        //            }
        //            .frame(minWidth: 400, minHeight: 300)
        //            .toolbar {
        //                if hasLogs {
        //                    ToolbarItem {
        //                        Button(action: {
        //                            copyLogsToClipboard()
        //                        }) {
        //                            Image(systemName: "doc.on.doc")
        //                        }
        //                    }
        //                }
        //            }
        //        #endif
        #if os(macOS)
            VStack {
                content
                HStack {
                    Button(action: {
                        copyLogsToClipboard()
                    }) {
                        Image(systemName: "doc.on.doc")
                    }
                    Spacer()
                    Button("Close") {
                        dismiss()
                    }
                }
                .padding()
            }
            .frame(minWidth: 400, minHeight: 300)
        #endif
    }

    private var content: some View {
        VStack(spacing: 0) {
            // Search bar
            HStack {
                Image(systemName: "magnifyingglass")
                    .foregroundColor(.secondary)
                TextField("Search logs", text: $searchText)
            }
            .padding(8)
            .background(Color.secondary.opacity(0.1))
            .cornerRadius(8)
            .padding()

            // Logs content
            if hasLogs {
                ScrollView {
                    Text(filteredLogs)
                        .font(.system(.body, design: .monospaced))
                        .padding()
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .textSelection(.enabled)
                }
                .background(Color(Color.background))
            } else {
                VStack(spacing: 16) {
                    Image(systemName: "doc.text")
                        .font(.system(size: 60))
                        .foregroundColor(.secondary)
                    Text("No Logs")
                        .font(.title2)
                        .foregroundColor(.secondary)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .padding()
                .multilineTextAlignment(.center)  // Center the text
            }
        }
    }

    private var filteredLogs: String {
        if searchText.isEmpty {
            return logs
        } else {
            return logs.split(separator: "\n")
                .filter { $0.localizedCaseInsensitiveContains(searchText) }
                .joined(separator: "\n")
        }
    }

    private var hasLogs: Bool {
        !filteredLogs.isEmpty
    }

    private func copyLogsToClipboard() {
        #if os(iOS)
            UIPasteboard.general.string = filteredLogs
        #elseif os(macOS)
            let pasteboard = NSPasteboard.general
            pasteboard.clearContents()
            pasteboard.setString(filteredLogs, forType: .string)
        #endif
        showCopyAlert = true
    }
}

// WebShieldApp/View/Navbar/Toolbar/NativeStyleTextEditor.swift
//
//  NativeStyleTextEditor.swift
//  WebShieldApp
//
//  Created by Arjun on 2024-09-08.
//

import Foundation
import SwiftUI

struct NativeStyleTextEditor: View {
    @Binding var text: String
    var placeholder: String

    var body: some View {
        ZStack(alignment: .topLeading) {
            if text.isEmpty {
                Text(placeholder)
//                    .foregroundColor(Color(.placeholderTextColor))
                    .padding(.horizontal, 8)
                    .padding(.vertical, 12)
            }
            TextEditor(text: $text)
                .padding(4)
        }
        .font(.body)
        .overlay(
            RoundedRectangle(cornerRadius: 8)
                .stroke(Color(.systemGray), lineWidth: 1)
        )
//        .background(Color(.textBackgroundColor))
    }
}

// WebShieldApp/View/PulsatingEffect.swift
//
//  PulseEffect.swift
//  WebShield
//
//  Created by Arjun on 2024-10-12.
//

import SwiftUI

struct PulsatingEffect: ViewModifier {
    var apply: Bool
    @State private var animate = false

    func body(content: Content) -> some View {
        content
            .scaleEffect(animate ? 1.0 : 1.1)
            .animation(
                apply
                    ? Animation.easeInOut(duration: 0.8).repeatForever(
                        autoreverses: true) : .default,
                value: animate
            )
            .onChange(of: apply) {
                animate = apply
            }
            .onAppear {
                animate = apply
            }
    }
}

// WebShieldApp/ViewModel/ContentViewModel.swift
//
//  ContentViewModel.swift
//  WebShieldApp
//
//  Created by Arjun on 2024-07-16.
//

import Foundation

final class ContentViewModel: ObservableObject {
    @Published var selectedCategory: FilterListCategory? = .all
    let filterListManager: FilterListManager

    @MainActor
    init(filterListManager: FilterListManager = FilterListManager()) {
        self.filterListManager = filterListManager
    }
}

// WebShieldApp/WebShieldApp.swift
//
//  WebShieldApp.swift
//  WebShield
//
//  Created by Arjun on 24/6/24.
//

import SwiftData
import SwiftUI

@main
struct WebShieldApp: App {
    @StateObject private var filterListManager = FilterListManager()
    @Environment(\.scenePhase) private var scenePhase

    var sharedModelContainer: ModelContainer = {
        let schema = Schema([
            Item.self
        ])
        let modelConfiguration = ModelConfiguration(
            schema: schema, isStoredInMemoryOnly: false)

        do {
            return try ModelContainer(
                for: schema, configurations: [modelConfiguration])
        } catch {
            print("[WS ERROR] IN WSA MAIN")
            fatalError("Could not create ModelContainer: \(error)")
        }
    }()

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(filterListManager)
        }
        .onChange(of: scenePhase) { newPhase, _ in
            if newPhase == .background || newPhase == .inactive {
                filterListManager.saveFilterLists()
            }
        }
    }

}

// WebShieldContentBlocker/ContentBlockerRequestHandler.swift
import Foundation

class ContentBlockerRequestHandler: NSObject, NSExtensionRequestHandling {
    func beginRequest(with context: NSExtensionContext) {
        let requiredPart = "G5S45S77DF.me.arjuna.WebShield"
        let blockerlistURL = FileManager.default
            .containerURL(
                forSecurityApplicationGroupIdentifier: requiredPart)!.appending(
                path: "blockerList.json",
                directoryHint: URL.DirectoryHint.notDirectory
            )
        guard FileManager.default.fileExists(atPath: blockerlistURL.path)
        else {
            print("Content Blocker Error: blockerList.json does not exist")
            context.completeRequest(returningItems: nil, completionHandler: nil)
            return
        }
        let attachment = NSItemProvider(
            contentsOf: blockerlistURL)!
        let item = NSExtensionItem()
        item.attachments = [attachment]

        context.completeRequest(returningItems: [item], completionHandler: nil)
    }
}

// WebShieldExtra/ContentBlockerEngineWrapper.swift
//
//  ContentBlockerEngineWrapper.swift
//  WebShieldScripts
//
//  Created by Arjun on 2024-07-13.
//

// WebShieldExtra/ContentBlockerEngineWrapper.swift

import ContentBlockerEngine
import Foundation

class ContentBlockerEngineWrapper {  // No changes to the class itself
    private var contentBlockerEngine: ContentBlockerEngine  // Isolate to main actor
    let shared = ContentBlockerEngineWrapper()  // shared instance remains

    init() {  // init is already main actor isolated
        let requiredPart: String = "G5S45S77DF.me.arjuna.WebShield"
        let advancedBlockingURL: URL? = FileManager.default
            .containerURL(
                forSecurityApplicationGroupIdentifier: requiredPart)?.appending(
                path: "advancedBlocking.json",
                directoryHint: URL.DirectoryHint.notDirectory
            )
        let json: String = try! String(  // Force-try still not ideal; handle errors
            contentsOf: advancedBlockingURL!,
            encoding: .utf8
        )

        self.contentBlockerEngine = try! ContentBlockerEngine(json)  // Force-try not ideal; handle potential errors here
    }

    public func getData(url: URL) -> String {  // Must be isolated to MainActor too
        return try! self.contentBlockerEngine.getData(url: url)  // Handle errors! Don't force-try in production code.
    }
}

// WebShieldExtra/SafariExtensionHandler.swift
//
//  SafariExtensionHandler.swift
//  Test
//
//  Created by Arjun on 2024-07-13.
//

import ContentBlockerEngine
import SafariServices
import os.log

class SafariExtensionHandler: SFSafariExtensionHandler {
    let logger = Logger()
    let contentBlockerEngineWrapper = ContentBlockerEngineWrapper()
    @MainActor let safariExtensionViewController = SafariExtensionViewController()
    override func beginRequest(with context: NSExtensionContext) {
        guard let request = context.inputItems.first as? NSExtensionItem,
            request.userInfo as? [String: Any] != nil
        else {
            return
        }
        let profile: UUID?
        if #available(iOS 17.0, macOS 14.0, *) {
            profile = request.userInfo?[SFExtensionProfileKey] as? UUID
        } else {
            profile = request.userInfo?["profile"] as? UUID
        }
        self.logger.log(
            level: .default,
            "The extension received a request for profile: \(profile!.uuidString, privacy: .public)"
        )
    }

    override func messageReceived(
        withName messageName: String, from page: SFSafariPage,
        userInfo: [String: Any]?
    ) {
        page.getPropertiesWithCompletionHandler { properties in
            self.logger.log(
                level: .default,
                "The extension received a message \(messageName, privacy: .public) from a script injected into \(String(describing: properties?.url), privacy: .public) with userInfo \(userInfo!, privacy: .public)"
            )
        }
        // Content script requests scripts and css for current page
        if messageName == "getAdvancedBlockingData" {
            if userInfo == nil || userInfo!["url"] == nil {
                self.logger.log(
                    level: .default, "Empty url passed with the message")
                return
            }
            let url = userInfo?["url"] as? String

            let pageUrl = URL(string: url!)!
            let data: [String: Any]? = [
                "url": url!,
                "data": contentBlockerEngineWrapper.getData(
                    url: pageUrl),
                "verbose": true,
            ]
            page.dispatchMessageToScript(
                withName: "advancedBlockingData", userInfo: data)
        }

    }

    override func toolbarItemClicked(in window: SFSafariWindow) {
        os_log(.default, "The extension's toolbar item was clicked")
    }

    override func validateToolbarItem(
        in window: SFSafariWindow,
        validationHandler: @escaping ((Bool, String) -> Void)
    ) {
        validationHandler(true, "")
    }

    override func popoverViewController()
        -> SFSafariExtensionViewController
    {
        return safariExtensionViewController.shared
    }

}

// WebShieldExtra/SafariExtensionViewController.swift
//
//  SafariExtensionViewController.swift
//  Test
//
//  Created by Arjun on 2024-07-13.
//

import SafariServices

class SafariExtensionViewController: SFSafariExtensionViewController {

    let shared: SafariExtensionViewController = {
        let shared = SafariExtensionViewController()
        shared.preferredContentSize = NSSize(width: 320, height: 240)
        return shared
    }()

}

