
// WebShieldAds/Source/ContentBlockerRequestHandler.swift
import Foundation
import os

private let logger = Logger(subsystem: "dev.arjuna.WebShield.DeclarativeBlockList-Ads", category: "ContentBlockerRequestHandler")

final class ContentBlockerRequestHandler: NSObject, NSExtensionRequestHandling {
    func beginRequest(with context: NSExtensionContext) {
        let requiredPart = "group.dev.arjuna.WebShield"

        logger.log("Content Blocker logging...")

        guard
            let containerURL = FileManager.default.containerURL(
                forSecurityApplicationGroupIdentifier: requiredPart)
        else {
            logger.log(
                "Error: Could not get container URL for group \(requiredPart, privacy: .public)")
            context.completeRequest(returningItems: nil, completionHandler: nil)
            return
        }

        logger.log("Successfully got container URL for group \(requiredPart, privacy: .public)")

        let blockerlistURL = containerURL.appendingPathComponent(
            "ads.json")

        guard FileManager.default.fileExists(atPath: blockerlistURL.path) else {
            logger.log("Content Blocker Error: ads.json does not exist")
            context.completeRequest(returningItems: nil, completionHandler: nil)
            return
        }

        logger.log("ads.json exists")

        if let attachment = NSItemProvider(contentsOf: blockerlistURL) {
            logger.log("Sending attachment")
            let item = NSExtensionItem()
            item.attachments = [attachment]
            context.completeRequest(
                returningItems: [item], completionHandler: nil)
            logger.log("Completed request")
        } else {
            logger.log(
                "Error: Could not create NSItemProvider for \(blockerlistURL)")
            context.completeRequest(returningItems: nil, completionHandler: nil)
        }

    }
}

// WebShieldAdvanced/Source/ChunkFileReader.swift
import Foundation
import OSLog

final class ChunkFileReader {

    private let logger: Logger
    private let chunkSize: UInt64
    private var fileHandle: FileHandle?
    private var offset: UInt64 = 0

    init?(fileURL: URL, chunkSize: UInt64 = 65536, logger: Logger) {
        self.logger = logger
        guard let fileHandle = try? FileHandle(forReadingFrom: fileURL) else {
            logger.error("ChunkFileReader init error: \(ContentBlockerError.fileNotFound(fileURL), privacy: .public)")
            return nil
        }
        self.chunkSize = chunkSize
        self.fileHandle = fileHandle
    }

    deinit {
        close()
    }

    func nextChunk() -> String? {
        guard let fileHandle = fileHandle else {
            logger.error("ChunkFileReader: Attempt to read from closed file")
            return nil
        }

        do {
            if let data = try fileHandle.read(upToCount: Int(chunkSize)) {
                let dataLength = UInt64(data.count)

                // Check if we actually read data
                guard dataLength > 0 else {
                    return nil
                }

                offset += dataLength
                try fileHandle.seek(toOffset: offset)
                return String(data: data, encoding: .utf8)
            } else {
                return nil
            }
        } catch {
            logger.error("ChunkFileReader error reading file: \(error, privacy: .public)")
            return nil
        }
    }

    func rewind() -> Bool {
        guard let fileHandle = fileHandle else {
            logger.error("ChunkFileReader: Attempt to rewind with closed file")
            return false
        }

        do {
            try fileHandle.seek(toOffset: 0)
            offset = 0
            return true
        } catch {
            logger.error("ChunkFileReader error when rewinding: \(error, privacy: .public)")
            return false
        }
    }

    func close() {
        do {
            try fileHandle?.close()
        } catch {
            logger.error("ChunkFileReader error closing file: \(error, privacy: .public)")
        }
        fileHandle = nil
    }
}

// MARK: - ChunkFileReader + Sequence

extension ChunkFileReader: Sequence {
    func makeIterator() -> some IteratorProtocol { AnyIterator { self.nextChunk() } }
}

// WebShieldAdvanced/Source/ContentBlockerEngineWrapper.swift
@preconcurrency import ContentBlockerEngine
import Foundation
import OSLog

final class ContentBlockerEngineWrapper: Sendable {
    // MARK: - Properties

    private let contentBlockerEngine: ContentBlockerEngine
    private let logger: Logger
    private let advancedBlockingURL: URL

    static let shared = ContentBlockerEngineWrapper()

    // MARK: - Initializers

    private init() {
        self.logger = Logger(subsystem: "dev.arjuna.WebShield", category: "ContentBlockerEngineWrapper")
        let appGroupID = AppGroupID(value: "group.dev.arjuna.WebShield")

        // Initialize advancedBlockingURL here
        guard
            let containerURL = FileManager.default.containerURL(
                forSecurityApplicationGroupIdentifier: appGroupID.value)
        else {
            let error = ContentBlockerError.invalidAppGroupID(appGroupID.value)
            logger.error("Fatal error: \(error.localizedDescription, privacy: .public)")
            fatalError("Failed to initialize ContentBlockerEngineWrapper: \(error)")
        }
        self.advancedBlockingURL = containerURL.appendingPathComponent("advancedBlocking.json", isDirectory: false)

        let engine: ContentBlockerEngine

        do {
            engine = try ContentBlockerEngineWrapper.initializeEngine(
                for: appGroupID, logger: logger, advancedBlockingURL: advancedBlockingURL)
        } catch {
            logger.error("Fatal error: \(error.localizedDescription, privacy: .public)")
            fatalError("Failed to initialize ContentBlockerEngineWrapper: \(error)")
        }

        self.contentBlockerEngine = engine
    }

    // MARK: - Initialization Logic

    private static func initializeEngine(for appGroupID: AppGroupID, logger: Logger, advancedBlockingURL: URL) throws
        -> ContentBlockerEngine
    {
        logger.log(
            "advancedBlocking.json URL: \(advancedBlockingURL.absoluteString, privacy: .public)")

        let jsonData = try loadJSONData(from: advancedBlockingURL, logger: logger)

        // Decode JSON on a background thread (already done in your original code)
        return try createContentBlockerEngine(with: jsonData, url: advancedBlockingURL, logger: logger)
    }

    // MARK: - JSON Loading and Decoding

    private static func loadJSONData(from url: URL, logger: Logger) throws -> Data {
        logger.log("Attempting to read advancedBlocking.json")

        guard FileManager.default.fileExists(atPath: url.path) else {
            throw ContentBlockerError.fileNotFound(url)
        }

        do {
            let data = try Data(contentsOf: url)

            // Log the loaded JSON data for debugging
            if let jsonString = String(data: data, encoding: .utf8) {
                logger.log("Loaded JSON data: \(jsonString, privacy: .public)")
            } else {
                logger.error("Failed to decode JSON data as UTF-8 string")
            }

            return data
        } catch {
            throw ContentBlockerError.fileReadError(url, error)
        }
    }

    private static func createContentBlockerEngine(with data: Data, url: URL, logger: Logger) throws
        -> ContentBlockerEngine
    {
        do {
            // First, attempt to decode the Data into a String
            guard let jsonString = String(data: data, encoding: .utf8) else {
                throw ContentBlockerError.invalidJSONData(url)
            }

            logger.log("Attempting to create ContentBlockerEngine")
            // Now pass the jsonString to the ContentBlockerEngine initializer
            let engine = try ContentBlockerEngine(jsonString)
            logger.log("ContentBlockerEngine initialized successfully")

            // Log the engine's triggers for debugging
            // logger.log("ContentBlockerEngine triggers: \(engine.triggers, privacy: .public)")

            return engine
        } catch {
            logger.error(
                "Failed to initialize content blocker: \(error.localizedDescription, privacy: .public)")
            throw ContentBlockerError.engineInitializationError(error)
        }
    }

    // MARK: - Public API

    func getAdvancedBlockingURL() -> URL {
        return advancedBlockingURL
    }

    func getData(for url: URL) -> Result<String, ContentBlockerError> {
        logger.log("Getting data for URL: \(url.absoluteString, privacy: .public)")

        do {
            let data = try contentBlockerEngine.getData(url: url)
            logger.log("Data returned from engine (before JSON conversion): \(data, privacy: .public)")

            // Attempt to convert the data to a JSON object for debugging
            //            if let jsonData = try? JSONSerialization.jsonObject(with: data.data(using: .utf8)!, options: []) {
            //                logger.log("Data as JSON: \(jsonData, privacy: .public)")
            //            } else {
            //                logger.error("Could not convert data to JSON")
            //            }

            return .success(data)
        } catch {
            // Include underlying error message from ContentBlockerEngine
            let underlyingErrorMessage = (error as NSError).localizedDescription
            logger.error(
                "Failed to get data for URL: \(url.absoluteString, privacy: .public) - Error: \(underlyingErrorMessage, privacy: .public)"
            )
            return .failure(.dataRetrievalError(url, error, underlyingErrorMessage))
        }
    }

    func needsChunking(for url: URL) -> Bool {
        let result = getData(for: url)
        switch result {
        case .success(let data):
            return data.utf8.count > 32768  // Threshold for chunking (adjust as needed)
        case .failure:
            return false  // Don't chunk if there's an error
        }
    }
}

// WebShieldAdvanced/Source/SafariWebExtensionHandler.swift
import OSLog
import SafariServices

@available(macOS 13.0, iOS 16.0, *)
final class SafariWebExtensionHandler: NSObject, NSExtensionRequestHandling {

    // MARK: - Types

    private enum ExtensionError: Error {
        case missingInputItems
        case invalidMessageType
        case missingAction
        case unknownAction(String)
        case invalidURL(String?)
        case dataFetchFailed(String, Error)
    }

    // MARK: - Properties

    private static let logger = Logger(
        subsystem: "dev.arjuna.WebShield", category: "SafariWebExtensionHandler")
    private var fileReader: ChunkFileReader?
    private let contentBlockerEngineWrapper: ContentBlockerEngineWrapper

    // MARK: - Initializer

    override init() {
        self.contentBlockerEngineWrapper = ContentBlockerEngineWrapper.shared
        super.init()
        SafariWebExtensionHandler.logger.log("SafariWebExtensionHandler initialized")
    }

    // MARK: - NSExtensionRequestHandling

    func beginRequest(with context: NSExtensionContext) {
        SafariWebExtensionHandler.logger.log("beginRequest(with:) called *********************")

        let request = context.inputItems.first as? NSExtensionItem
        let message = request?.userInfo?[SFExtensionMessageKey] as? [String: Any]

        do {
            try self.handleRequest(message: message, context: context)
        } catch let error as ExtensionError {
            self.handleError(error, context: context)
        } catch {
            SafariWebExtensionHandler.logger.error("Unexpected error: \(error, privacy: .public)")
            self.sendErrorResponse(to: context, message: "An unexpected error occurred")
        }
    }

    // MARK: - Request Handling

    private func handleRequest(message: [String: Any]?, context: NSExtensionContext) throws {
        guard let message = message else {
            throw ExtensionError.invalidMessageType
        }

        guard let action = message["action"] as? String else {
            throw ExtensionError.missingAction
        }

        switch action {
        case "getAdvancedBlockingData":
            try handleGetAdvancedBlockingData(message: message, context: context)
        default:
            throw ExtensionError.unknownAction(action)
        }
    }

    // MARK: - Get Advanced Blocking Data

    private func handleGetAdvancedBlockingData(message: [String: Any], context: NSExtensionContext) throws {
        SafariWebExtensionHandler.logger.log("Handling getAdvancedBlockingData")

        guard let urlString = message["url"] as? String, let pageUrl = URL(string: urlString) else {
            throw ExtensionError.invalidURL(message["url"] as? String)
        }

        SafariWebExtensionHandler.logger.log("Fetching data for URL: \(urlString)")

        // Get the 'fromBeginning' flag, defaulting to false if not provided
        let fromBeginning = message["fromBeginning"] as? Bool ?? false

        // Use ContentBlockerEngineWrapper to determine if chunking is needed
        let needsChunking = contentBlockerEngineWrapper.needsChunking(for: pageUrl)

        if needsChunking {
            // Handle chunked response
            handleChunkedResponse(for: pageUrl, fromBeginning: fromBeginning, context: context)
        } else {
            // Handle regular response
            let result = contentBlockerEngineWrapper.getData(for: pageUrl)
            switch result {
            case .success(let blockingData):
                SafariWebExtensionHandler.logger.log("Got blocking data: \(blockingData, privacy: .public)")
                let response: [String: Any] = [
                    "url": urlString,
                    "data": blockingData,
                    "verbose": true,
                    "chunked": false,
                ]
                sendResponse(to: context, data: response)

            case .failure(let error):
                throw ExtensionError.dataFetchFailed(urlString, error)
            }
        }
    }

    private func handleChunkedResponse(for url: URL, fromBeginning: Bool, context: NSExtensionContext) {
        let advancedRulesFileUrl = contentBlockerEngineWrapper.getAdvancedBlockingURL()

        // Create file reader object if it doesn't exist
        if fileReader == nil {
            fileReader = ChunkFileReader(
                fileURL: advancedRulesFileUrl, chunkSize: 65536, logger: SafariWebExtensionHandler.logger)
        }
        // Rewind file reader if fromBeginning is true
        else if fromBeginning {
            let success = fileReader?.rewind() ?? false
            if !success {
                sendErrorResponse(to: context, message: "Failed to rewind file")
                return
            }
        }

        if let chunk = fileReader?.nextChunk() {
            let response: [String: Any] = [
                "url": url.absoluteString,
                "data": chunk,
                "chunked": true,
                "more": true,
            ]
            sendResponse(to: context, data: response)
        } else {
            fileReader?.close()
            fileReader = nil
            let response: [String: Any] = [
                "url": url.absoluteString,
                "chunked": true,
                "more": false,
            ]
            sendResponse(to: context, data: response)
        }
    }

    // MARK: - Response Handling

    private func sendResponse(to context: NSExtensionContext, data: [String: Any]) {
        let response = NSExtensionItem()
        response.userInfo = [SFExtensionMessageKey: data]

        SafariWebExtensionHandler.logger.log(
            "Sending final response: \(String(describing: response.userInfo), privacy: .public)")

        context.completeRequest(returningItems: [response]) { success in
            if success {
                SafariWebExtensionHandler.logger.log("Request completed successfully")
            } else {
                SafariWebExtensionHandler.logger.error("Error completing request")
            }
        }
    }

    // MARK: - Error Handling

    private func handleError(_ error: ExtensionError, context: NSExtensionContext) {
        switch error {
        case .missingInputItems:
            SafariWebExtensionHandler.logger.error("Invalid request: No input items found")
            sendErrorResponse(to: context, message: "Invalid request")
        case .invalidMessageType:
            SafariWebExtensionHandler.logger.error("Invalid message type")
            sendErrorResponse(to: context, message: "Invalid message")
        case .missingAction:
            SafariWebExtensionHandler.logger.error("Invalid or missing action in message")
            sendErrorResponse(to: context, message: "Invalid action")
        case .unknownAction(let action):
            SafariWebExtensionHandler.logger.error("Unknown action: \(action, privacy: .public)")
            sendErrorResponse(to: context, message: "Unknown action: \(action)")
        case .invalidURL(let urlString):
            SafariWebExtensionHandler.logger.error("Invalid URL in message: \(urlString ?? "nil", privacy: .public)")
            sendErrorResponse(to: context, message: "Invalid URL")
        case .dataFetchFailed(let urlString, let underlyingError):
            SafariWebExtensionHandler.logger.error(
                "Failed to fetch blocking data for URL: \(urlString), Error: \(underlyingError, privacy: .public)")
            sendErrorResponse(to: context, message: "Failed to fetch blocking data")
        }
    }

    private func sendErrorResponse(to context: NSExtensionContext, message: String) {
        let errorResponse: [String: Any] = ["error": message]
        sendResponse(to: context, data: errorResponse)
    }
}

// WebShieldAdvanced/Source/SharedTypes.swift
import Foundation

// MARK: - App Group
struct AppGroupID: Sendable {
    let value: String
}

// MARK: - Shared URL

protocol SharedStorageURLs {
    var sharedContainerURL: URL { get }
    var advancedBlockingRulesURL: URL { get }
}

// MARK: - Shared Error

enum ContentBlockerError: Error {
    case invalidAppGroupID(String)
    case fileNotFound(URL)
    case fileReadError(URL, Error)
    case jsonDecodeError(URL, Error)
    case engineInitializationError(Error)
    case dataRetrievalError(URL, Error, String?)  // Now includes underlying error message
    case invalidJSONData(URL)
    case chunkingError(String)
}

// WebShieldAnnoyances/Source/ContentBlockerRequestHandler.swift
import Foundation
import os

private let logger = Logger(
    subsystem: "dev.arjuna.WebShield.DeclarativeBlockList-Annoyances", category: "ContentBlockerRequestHandler")
private let specificList = "annoyances.json"

final class ContentBlockerRequestHandler: NSObject, NSExtensionRequestHandling {
    func beginRequest(with context: NSExtensionContext) {
        let requiredPart = "group.dev.arjuna.WebShield"

        logger.log("Content Blocker logging...")

        guard
            let containerURL = FileManager.default.containerURL(
                forSecurityApplicationGroupIdentifier: requiredPart)
        else {
            logger.log(
                "Error: Could not get container URL for group \(requiredPart, privacy: .public)")
            context.completeRequest(returningItems: nil, completionHandler: nil)
            return
        }

        logger.log("Successfully got container URL for group \(requiredPart, privacy: .public)")

        let blockerlistURL = containerURL.appendingPathComponent(
            "\(specificList)")

        guard FileManager.default.fileExists(atPath: blockerlistURL.path) else {
            logger.log("Content Blocker Error: \(specificList) does not exist")
            context.completeRequest(returningItems: nil, completionHandler: nil)
            return
        }

        logger.log("\(specificList) exists")

        if let attachment = NSItemProvider(contentsOf: blockerlistURL) {
            logger.log("Sending attachment")
            let item = NSExtensionItem()
            item.attachments = [attachment]
            context.completeRequest(
                returningItems: [item], completionHandler: nil)
            logger.log("Completed request")
        } else {
            logger.log(
                "Error: Could not create NSItemProvider for \(blockerlistURL)")
            context.completeRequest(returningItems: nil, completionHandler: nil)
        }

    }
}

// WebShieldApp/Source/App/AppSettings.swift
import Foundation

@MainActor
final class AppSettings {
    static let shared = AppSettings() // Singleton instance

    private init() {} // Private initializer to enforce singleton

    private let initialRefreshKey = "hasPerformedInitialRefresh"
    @Published var lastRefreshedEnabledFilters: Set<String> = [] // Store identifiers of enabled filters

    @Published var hasPerformedInitialRefresh: Bool = false


//    var hasPerformedInitialRefresh: Bool {
//        get {
//            UserDefaults.standard.bool(forKey: initialRefreshKey)
//        }
//        set {
//            UserDefaults.standard.set(newValue, forKey: initialRefreshKey)
//        }
//    }

    // ... other settings properties ...
}

// WebShieldApp/Source/App/GroupContainerURL.swift
import Foundation

@MainActor
struct GroupContainerURL {
    private static let fileManager: FileManager = FileManager.default
    static func groupContainerURL() -> URL? {
        return fileManager.containerURL(
            forSecurityApplicationGroupIdentifier:
                Identifiers.groupID)
    }
}

// WebShieldApp/Source/App/Identifiers.swift
import Foundation

public enum Identifiers {
    static let groupID: String = "group.dev.arjuna.WebShield"
}

// WebShieldApp/Source/App/WebShieldApp.swift
import SwiftData
import SwiftUI

@main
struct WebShieldApp: App {
    @StateObject private var dataManager = DataManager()
    @StateObject private var refreshErrorViewModel = RefreshErrorViewModel()
    @StateObject private var contentBlockerState: ContentBlockerState
    @StateObject private var advancedExtensionState = WebExtensionState()

    init() {
        let refreshErrorViewModel = RefreshErrorViewModel()
        _refreshErrorViewModel = StateObject(wrappedValue: refreshErrorViewModel)
        _contentBlockerState = StateObject(
            wrappedValue: ContentBlockerState(refreshErrorViewModel: refreshErrorViewModel))
    }

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(dataManager)
                .environmentObject(contentBlockerState)
                .environmentObject(advancedExtensionState)
                .environmentObject(refreshErrorViewModel)
                .modelContainer(dataManager.container)
                .onAppear {
                    Task {
                        await dataManager.seedDataIfNeeded()
                    }
                }
        }
    }

}

// WebShieldApp/Source/Extensions/ColorExtension.swift
#if os(macOS)
    import Foundation
    import SwiftUI

    extension Color {
        static let background = Color(NSColor.windowBackgroundColor)
        static let secondaryBackground = Color(NSColor.underPageBackgroundColor)
        static let tertiaryBackground = Color(NSColor.controlBackgroundColor)
    }
#endif

// WebShieldApp/Source/Extensions/ModelContextExtension.swift
import Foundation
import SwiftData

extension ModelContext {
    func deleteAll<T: PersistentModel>(_ type: T.Type) throws {
        let fetchDescriptor = FetchDescriptor<T>()
        let results = try fetch(fetchDescriptor)
        for object in results {
            delete(object)
        }
    }
}

// WebShieldApp/Source/Models/FilterList.swift
import Foundation
import SwiftData

// MARK: - Model
@Model
final class FilterList: Identifiable, Hashable {
    @Attribute(.unique) var id: String
    var name: String = "No Name"
    var version: String = "N/A"
    var desc: String = "No Description"
    var categoryString: String = FilterListCategory.custom.rawValue
    var isEnabled: Bool = false
    var order: Int = 0
    var downloadUrl: String? = "https://example.com"
    var homepageUrl: String? = "https://example.com"
    var standardRuleCount: Int = 0
    var advancedRuleCount: Int = 0
    var lastUpdated: Date = Date()
    var informationUrl: String? = "https://example.com"
    var downloaded: Bool = false
    var needsRefresh: Bool = true

    // Initializer
    init(
        name: String = "No Name",
        version: String = "No Version",
        desc: String = "No Description",
        category: FilterListCategory,
        isEnabled: Bool = false,
        order: Int = 0,
        downloadUrl: String? = nil,
        homepageUrl: String? = nil,
        informationUrl: String? = nil,
        downloaded: Bool = false,
        needsRefresh: Bool = true
    ) {
        self.id = UUID().uuidString
        self.name = name
        self.version = version
        self.desc = desc
        self.categoryString = category.rawValue
        self.isEnabled = isEnabled
        self.order = order
        self.downloadUrl = downloadUrl
        self.homepageUrl = homepageUrl
        self.informationUrl = informationUrl
        self.downloaded = false
        self.needsRefresh = true
    }

    static func == (lhs: FilterList, rhs: FilterList) -> Bool {
        lhs.id == rhs.id
    }

    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }

    var category: FilterListCategory? {
        FilterListCategory(rawValue: categoryString)
    }

    var totalRuleCount: Int {
        standardRuleCount + advancedRuleCount
    }
}

// WebShieldApp/Source/Models/FilterListCategory.swift
import SwiftUI

// Add Codable conformance
enum FilterListCategory: String, CaseIterable, Identifiable, Codable {
    case all = "All"
    case ads = "Ads"
    case privacy = "Privacy"
    case security = "Security"
    case multipurpose = "Multipurpose"
    case cookies = "Cookies"
    case social = "Social"
    case annoyances = "Annoyances"
    case regional = "Regional"
    case experimental = "Experimental"
    case custom = "Custom"

    var id: String { self.rawValue }

    var systemImage: String {
        switch self {
        case .all: return "square.grid.2x2"
        case .ads: return "megaphone"
        case .privacy: return "hand.raised"
        case .security: return "lock"
        case .multipurpose: return "square.stack.3d.down.right"
        case .cookies: return "circle.dotted.circle"
        case .social: return "bubble.left.and.bubble.right"
        case .annoyances: return "exclamationmark.triangle"
        case .regional: return "globe"
        case .experimental: return "flask"
        case .custom: return "slider.horizontal.3"
        }
    }
}

// WebShieldApp/Source/Models/FilterListData.swift
import Foundation

struct FilterListData {
    let id: String
    let name: String
    let downloadUrl: String
    let category: FilterListCategory
    let isSelected: Bool
    let description: String
    let homepageUrl: String?
    let informationUrl: String?
    
    init(
        id: String,
        name: String,
        downloadUrl: String,
        category: FilterListCategory,
        isSelected: Bool,
        description: String,
        homepageUrl: String? = nil,
        informationUrl: String? = nil
    ) {
        self.id = id
        self.name = name
        self.downloadUrl = downloadUrl
        self.category = category
        self.isSelected = isSelected
        self.description = description
        self.homepageUrl = homepageUrl
        self.informationUrl = informationUrl
    }
}

// WebShieldApp/Source/Models/FilterListError.swift
import Foundation

enum FilterListError: LocalizedError {
    case invalidData
    case invalidFormat
    case downloadFailed
    case parsingFailed
    case invalidURL
    case invalidServerResponse

    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "The provided URL is not valid."
        case .invalidData:
            return "Invalid filter list data"
        case .invalidFormat:
            return "Invalid filter list format"
        case .downloadFailed:
            return "Failed to download filter list"
        case .parsingFailed:
            return "Failed to parse filter list"
            case .invalidServerResponse:
                return "Failed to receive filter list from URL due to invalid server response"
        }
    }
}

// WebShieldApp/Source/Models/FilterListSection.swift
import Foundation

struct FilterListSection: Identifiable {
    let title: String
    let filterLists: [FilterList]
    let category: FilterListCategory
    var id: String { title }
}

// WebShieldApp/Source/Models/ParsedMetadata.swift
import Foundation

/// A simple struct to hold metadata parsed from filter list text.
struct ParsedMetadata {
    var version: String
    var homepage: String?
}

// WebShieldApp/Source/Models/ProcessedConversionResult.swift
import Foundation

/// Simple container for the results of a single filter list conversion
struct ProcessedConversionResult {
    /// The regular JSON string (Safari content blocker format)
    let converted: String?
    /// The advanced blocking JSON string (if any)
    let advancedBlocking: String?
    /// Count of standard rules
    let convertedCount: Int
    /// Count of advanced rules
    let advancedBlockingCount: Int
    /// Number of errors encountered
    let errorsCount: Int
    /// If the converter found the rules were over the size limit
    let overLimit: Bool
    /// A human-readable message about the conversion
    let message: String?
}

// WebShieldApp/Source/Models/TotalStats.swift
public struct TotalStats {
    var totalConvertedCount: Int = 0
    var convertedCount: Int = 0
    var errorsCount: Int = 0
    var overLimit: Int = 0
}

// WebShieldApp/Source/Models/TrustedSite.swift
import Foundation
import SwiftData
import SwiftUI

@Model
final class TrustedSite {
    @Attribute(.unique) var id: String
    var domain: String

    init(domain: String) {
        self.id = UUID().uuidString
        self.domain = domain
    }
}

// WebShieldApp/Source/Providers/FilterListProvider.swift
import Foundation

private let baseUrl = "https://filters.adtidy.org/"
#if os(macOS)
    private let subUrl = "extension/safari"
    private let ifDesktopEnabled = false
#elseif os(iOS) || os(visionOS)
    private let subUrl = "ios"
    private let ifDesktopEnabled = true
#endif
private let filterSubUrl = "/filters"
private let partiallyFullUrl = baseUrl + subUrl + filterSubUrl

enum FilterListProvider {

    static let filterListData: [FilterListData] = [
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard – Ads",
            downloadUrl:
                "\(partiallyFullUrl)/2_optimized.txt",
            category: .ads,
            isSelected: true,
            description:
                "EasyList + AdGuard English filter. This filter is necessary for quality ad blocking.",
            homepageUrl:
                "https://github.com/AdguardTeam/AdguardFilters#adguard-filters",
            informationUrl:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard – Mobile Ads",
            downloadUrl:
                "\(partiallyFullUrl)/11_optimized.txt",
            category: .ads,
            isSelected: ifDesktopEnabled,
            description:
                "Filter for all known mobile ad networks. Useful for mobile devices.",
            homepageUrl:
                "https://github.com/AdguardTeam/AdguardFilters#adguard-filters",
            informationUrl:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "EasyList",
            downloadUrl:
                "\(partiallyFullUrl)/101_optimized.txt",
            category: .ads,
            isSelected: false,
            description:
                "EasyList is the primary subscription that removes adverts from web pages in English. Already included in AdGuard Base filter.",
            homepageUrl: "https://easylist.to/"),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard Tracking Protection",
            downloadUrl:
                "\(partiallyFullUrl)/3_optimized.txt",
            category: .privacy,
            isSelected: true,
            description:
                "The most comprehensive list of various online counters and web analytics tools. Use this filter if you do not want your actions on the Internet to be tracked.",
            homepageUrl:
                "https://github.com/AdguardTeam/AdguardFilters#adguard-filters",
            informationUrl:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"),
        FilterListData(
            id: UUID().uuidString,
            name: "EasyPrivacy",
            downloadUrl:
                "\(partiallyFullUrl)/118_optimized.txt",
            category: .privacy,
            isSelected: true,
            description:
                "Privacy protection supplement for EasyList.",
            homepageUrl: "https://easylist.to/"),
        FilterListData(
            id: UUID().uuidString,
            name: "Online Malicious URL Blocklist",
            downloadUrl:
                "\(partiallyFullUrl)/208_optimized.txt",
            category: .security,
            isSelected: false,
            description:
                "Blocks domains that are known to be used to propagate malware and spyware.",
            homepageUrl:
                "https://gitlab.com/malware-filter/urlhaus-filter#malicious-url-blocklist"),
        FilterListData(
            id: UUID().uuidString,
            name: "Phishing URL Blocklist",
            downloadUrl:
                "\(partiallyFullUrl)/255_optimized.txt",
            category: .security,
            isSelected: false,
            description:
                "Phishing URL blocklist for uBlock Origin (uBO), AdGuard, Vivaldi, Pi-hole, Hosts file, Dnsmasq, BIND, Unbound, Snort and Suricata.",
            homepageUrl:
                "https://gitlab.com/malware-filter/phishing-filter#phishing-url-blocklist"),
        FilterListData(
            id: UUID().uuidString,
            name: "Peter Lowe’s Ad and tracking server list",
            downloadUrl:
                "\(partiallyFullUrl)/204_optimized.txt",
            category: .multipurpose,
            isSelected: false,
            description:
                "Filter that blocks ads, trackers, and other nasty things.",
            homepageUrl: "https://pgl.yoyo.org/adservers/"),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard – Cookie Notices",
            downloadUrl:
                "\(partiallyFullUrl)/18_optimized.txt",
            category: .cookies,
            isSelected: false,
            description:
                "Blocks cookie notices on web pages.",
            homepageUrl:
                "https://github.com/AdguardTeam/AdguardFilters#adguard-filters",
            informationUrl:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"),
        FilterListData(
            id: UUID().uuidString,
            name: "EasyList – Cookie Notices",
            downloadUrl:
                "\(partiallyFullUrl)/241_optimized.txt",
            category: .cookies,
            isSelected: false,
            description:
                "Removes cookie and privacy warnings. Already included in Fanboy's Annoyances list.",
            homepageUrl: "https://github.com/easylist/easylist#fanboy-lists"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard – Social Widgets",
            downloadUrl:
                "\(partiallyFullUrl)/4_optimized.txt",
            category: .social,
            isSelected: false,
            description:
                "Filter for social media widgets such as 'Like' and 'Share' buttons and more.",
            homepageUrl:
                "https://github.com/AdguardTeam/AdguardFilters#adguard-filters",
            informationUrl:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "Fanboy – Social Blocking",
            downloadUrl:
                "\(partiallyFullUrl)/123_optimized.txt",
            category: .social,
            isSelected: false,
            description:
                "Hides and blocks social content, social widgets, social scripts and social icons. Already included in Fanboy's Annoyances list.",
            homepageUrl: "https://github.com/ryanbr/fanboy-adblock/issues"),
        FilterListData(
            id: UUID().uuidString,
            name: "Fanboy – Anti-Facebook",
            downloadUrl:
                "\(partiallyFullUrl)/225_optimized.txt",
            category: .social,
            isSelected: false,
            description:
                "Warning, it will break Facebook-based comments on some websites and may also break some Facebook apps or games.",
            homepageUrl: "https://github.com/ryanbr/fanboy-adblock/issues"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard – Annoyances",
            downloadUrl:
                "\(partiallyFullUrl)/14_optimized.txt",
            category: .annoyances,
            isSelected: false,
            description:
                "Blocks irritating elements on web pages including cookie notices, third-party widgets and in-page pop-ups. Contains the following AdGuard filters: Cookie Notices, Popups, Mobile App Banners, Other Annoyances and Widgets.",
            homepageUrl:
                "https://github.com/AdguardTeam/AdguardFilters#adguard-filters",
            informationUrl:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard – Popup Overlays",
            downloadUrl:
                "\(partiallyFullUrl)/19_optimized.txt",
            category: .annoyances,
            isSelected: false,
            description:
                "Blocks all kinds of pop-ups that are not necessary for websites' operation according to our Filter policy.",
            homepageUrl:
                "https://github.com/AdguardTeam/AdguardFilters#adguard-filters",
            informationUrl:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard – Mobile App Banners",
            downloadUrl:
                "\(partiallyFullUrl)/20_optimized.txt",
            category: .annoyances,
            isSelected: false,
            description:
                "Blocks all kinds of pop-ups that are not necessary for websites' operation according to our Filter policy.",
            homepageUrl:
                "https://github.com/AdguardTeam/AdguardFilters#adguard-filters",
            informationUrl:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard – Other Annoyances",
            downloadUrl:
                "\(partiallyFullUrl)/21_optimized.txt",
            category: .annoyances,
            isSelected: false,
            description:
                "Blocks irritating elements on web pages that do not fall under the popular categories of annoyances.",
            homepageUrl:
                "https://github.com/AdguardTeam/AdguardFilters#adguard-filters",
            informationUrl:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard – Widgets",
            downloadUrl:
                "\(partiallyFullUrl)/22_optimized.txt",
            category: .annoyances,
            isSelected: false,
            description:
                "Blocks annoying third-party widgets: online assistants, live support chats, etc.",
            homepageUrl:
                "https://github.com/AdguardTeam/AdguardFilters#adguard-filters",
            informationUrl:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"),
        FilterListData(
            id: UUID().uuidString,
            name: "Fanboy – Annoyances",
            downloadUrl:
                "\(partiallyFullUrl)/122_optimized.txt",
            category: .annoyances,
            isSelected: false,
            description:
                "Removes in-page pop-ups and other annoyances. Includes Fanboy's Social Blocking & EasyList Cookie Lists.",
            homepageUrl: "https://github.com/ryanbr/fanboy-adblock/issues"),

        FilterListData(
            id: UUID().uuidString,
            name: "🇷🇺ru: AdGuard Russian filter",
            downloadUrl:
                "\(partiallyFullUrl)/1_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Filter that enables ad blocking on websites in Russian language.",
            homepageUrl:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇩🇪de: AdGuard German filter",
            downloadUrl:
                "\(partiallyFullUrl)/6_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "EasyList Germany + AdGuard German filter. Filter list that specifically removes ads on websites in German language.",
            homepageUrl:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇯🇵jp: AdGuard Japanese filter",
            downloadUrl:
                "\(partiallyFullUrl)/7_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Filter that enables ad blocking on websites in Japanese language.",
            homepageUrl:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇳🇱nl: AdGuard Dutch filter",
            downloadUrl:
                "\(partiallyFullUrl)/8_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "EasyList Dutch + AdGuard Dutch filter. Filter list that specifically removes ads on websites in Dutch language.",
            homepageUrl:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇪🇸es🇦🇷ar🇵🇹pt🇧🇷br: AdGuard Spanish/Portuguese filter",
            downloadUrl:
                "\(partiallyFullUrl)/9_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Filter list that specifically removes ads on websites in Spanish, Portuguese, and Brazilian Portuguese languages.",
            homepageUrl:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇹🇷tr: AdGuard Turkish filter",
            downloadUrl:
                "\(partiallyFullUrl)/13_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Filter list that specifically removes ads on websites in Turkish language.",
            homepageUrl:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇫🇷fr: AdGuard French filter",
            downloadUrl:
                "\(partiallyFullUrl)/16_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Liste FR + AdGuard French filter. Filter list that specifically removes ads on websites in French language.",
            homepageUrl:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇺🇦ua: AdGuard Ukrainian filter",
            downloadUrl:
                "\(partiallyFullUrl)/23_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Filter that enables ad blocking on websites in Ukrainian language.",
            homepageUrl:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇮🇩id: ABPindo",
            downloadUrl:
                "\(partiallyFullUrl)/102_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Additional filter list for websites in Indonesian.",
            homepageUrl:
                "https://github.com/ABPindo/indonesianadblockrules"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇧🇬bg: Bulgarian list",
            downloadUrl:
                "\(partiallyFullUrl)/103_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Additional filter list for websites in Bulgarian.",
            homepageUrl:
                "https://github.com/RealEnder/adblockbg/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇨🇳cn🇹🇼tw: EasyList China",
            downloadUrl:
                "\(partiallyFullUrl)/104_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Additional filter list for websites in Chinese. Already included in AdGuard Chinese filter.",
            homepageUrl:
                "https://github.com/easylist/easylistchina"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇨🇿cz: EasyList Czech and Slovak",
            downloadUrl:
                "\(partiallyFullUrl)/105_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Additional filter list for websites in Czech and Slovak.",
            homepageUrl:
                "https://github.com/tomasko126/easylistczechandslovak"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇳🇱nl: EasyList Dutch",
            downloadUrl:
                "\(partiallyFullUrl)/106_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Additional filter list for websites in Dutch. Already included in AdGuard Dutch filter.",
            homepageUrl:
                "https://github.com/easylist/easylistdutch/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇩🇪de: EasyList Germany",
            downloadUrl:
                "\(partiallyFullUrl)/107_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Additional filter list for websites in German. Already included in AdGuard German filter.",
            homepageUrl:
                "https://github.com/easylist/easylistgermany/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇮🇱il: EasyList Hebrew",
            downloadUrl:
                "\(partiallyFullUrl)/108_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Additional filter list for websites in Hebrew.",
            homepageUrl:
                "https://github.com/easylist/EasyListHebrew"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇮🇹it: EasyList Italy",
            downloadUrl:
                "\(partiallyFullUrl)/109_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Additional filter list for websites in Italian.",
            homepageUrl:
                "https://github.com/easylist/easylistitaly/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇱🇹lt: EasyList Lithuania",
            downloadUrl:
                "\(partiallyFullUrl)/110_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Additional filter list for websites in Lithuanian.",
            homepageUrl:
                "https://github.com/EasyList-Lithuania/easylist_lithuania"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇱🇻lv: Latvian List",
            downloadUrl:
                "\(partiallyFullUrl)/111_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Additional filter list for websites in Latvian.",
            homepageUrl:
                "https://github.com/Latvian-List/adblock-latvian"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇸🇦sa: Liste AR",
            downloadUrl:
                "\(partiallyFullUrl)/112_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Additional filter list for websites in Arabic.",
            homepageUrl:
                "https://github.com/easylist/listear"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇫🇷fr: Liste FR",
            downloadUrl:
                "\(partiallyFullUrl)/113_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Additional filter list for websites in French. Already included in AdGuard French filter.",
            homepageUrl:
                "https://github.com/easylist/listefr"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇷🇴ro: ROList",
            downloadUrl:
                "\(partiallyFullUrl)/114_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Additional filter list for websites in Romanian.",
            homepageUrl:
                "https://www.zoso.ro/rolist"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇮🇸is: Icelandic ABP List",
            downloadUrl:
                "\(partiallyFullUrl)/119_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Additional filter list for websites in Icelandic.",
            homepageUrl:
                "https://adblock.gardar.net/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇮🇩id: AdBlockID",
            downloadUrl:
                "\(partiallyFullUrl)/120_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Additional filter list for websites in Indonesian.",
            homepageUrl:
                "https://github.com/realodix/AdBlockID"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇬🇷gr: Greek AdBlock Filter",
            downloadUrl:
                "\(partiallyFullUrl)/121_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Additional filter list for websites in Greek.",
            homepageUrl:
                "https://github.com/kargig/greek-adblockplus-filter"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇵🇹pt🇪🇸es: EasyList Portuguese",
            downloadUrl:
                "\(partiallyFullUrl)/124_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Additional filter list for websites in Spanish and Portuguese.",
            homepageUrl:
                "https://github.com/easylist/easylistportuguese"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇹🇭th: EasyList Thailand",
            downloadUrl:
                "\(partiallyFullUrl)/202_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Filter that blocks ads on Thai sites.",
            homepageUrl:
                "https://github.com/easylist-thailand/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇭🇺hu: Hungarian filter",
            downloadUrl:
                "\(partiallyFullUrl)/203_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Hufilter. Filter list that specifically removes ads on websites in the Hungarian language.",
            homepageUrl:
                "https://github.com/hufilter/hufilter/wiki"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇮🇹it: Xfiles",
            downloadUrl:
                "\(partiallyFullUrl)/206_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Italian adblock filter list.",
            homepageUrl:
                "https://xfiles.noads.it/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇷🇺ru🇺🇦ua: RU AdList: Counters",
            downloadUrl:
                "\(partiallyFullUrl)/212_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "RU AdList supplement for trackers blocking.",
            homepageUrl:
                "https://forums.lanik.us/viewforum.php?f=102"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇻🇳vn: ABPVN List",
            downloadUrl:
                "\(partiallyFullUrl)/214_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Vietnamese adblock filter list.",
            homepageUrl:
                "https://abpvn.com/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇵🇱pl: Official Polish filters for AdBlock, uBlock Origin & AdGuard",
            downloadUrl:
                "\(partiallyFullUrl)/216_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Additional filter list for websites in Polish.",
            homepageUrl:
                "https://github.com/MajkiIT/polish-ads-filter#polish-filters-for-adblock-ublock-origin--adguard"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇵🇱pl: Polish GDPR-Cookies Filters",
            downloadUrl:
                "\(partiallyFullUrl)/217_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Polish filter list for cookies blocking.",
            homepageUrl:
                "https://github.com/MajkiIT/polish-ads-filter#polish-filters-for-adblock-ublock-origin--adguard"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇪🇪ee: Estonian List",
            downloadUrl:
                "\(partiallyFullUrl)/218_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Filter for ad blocking on Estonian sites.",
            homepageUrl:
                "https://adblock.ee/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇨🇳cn🇹🇼tw: CJX's Annoyances List",
            downloadUrl:
                "\(partiallyFullUrl)/220_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Supplement for EasyList China+EasyList and EasyPrivacy.",
            homepageUrl:
                "https://github.com/cjx82630/cjxlist/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇵🇱pl: Polish Social Filters",
            downloadUrl:
                "\(partiallyFullUrl)/221_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Polish filter list for social widgets, popups, etc.",
            homepageUrl:
                "https://github.com/MajkiIT/polish-ads-filter#polish-filters-for-adblock-ublock-origin--adguard"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇨🇳cn🇹🇼tw: AdGuard Chinese filter",
            downloadUrl:
                "\(partiallyFullUrl)/224_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "EasyList China + AdGuard Chinese filter. Filter list that specifically removes ads on websites in Chinese language.",
            homepageUrl:
                "https://adguard.com/kb/general/ad-filtering/adguard-filters/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇰🇷kr: List-KR",
            downloadUrl:
                "\(partiallyFullUrl)/227_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Filter that removes ads and various scripts from websites with Korean content. Combined and augmented with AdGuard-specific rules for enhanced filtering. This filter is expected to be used alongside with AdGuard Base filter.",
            homepageUrl:
                "https://list-kr.github.io/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇨🇳cn🇹🇼tw: xinggsf",
            downloadUrl:
                "\(partiallyFullUrl)/228_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Blocks ads on the Chinese video platforms (MangoTV, DouYu and others).",
            homepageUrl:
                "https://github.com/xinggsf/Adblock-Plus-Rule/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇪🇸es: EasyList Spanish",
            downloadUrl:
                "\(partiallyFullUrl)/231_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Additional filter list for websites in Spanish.",
            homepageUrl:
                "https://github.com/easylist/easylistspanish"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇵🇱pl: KAD - Anti-Scam",
            downloadUrl:
                "\(partiallyFullUrl)/232_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Filter that protects against various types of scams in the Polish network, such as mass text messaging, fake online stores, etc.",
            homepageUrl:
                "https://github.com/FiltersHeroes/KAD"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇫🇮fi: Adblock List for Finland",
            downloadUrl:
                "\(partiallyFullUrl)/233_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Finnish ad blocking filter list.",
            homepageUrl:
                "https://github.com/finnish-easylist-addition/finnish-easylist-addition"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇷🇴ro: ROLIST2",
            downloadUrl:
                "\(partiallyFullUrl)/234_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "This is a complementary list for ROList with annoyances that are not necessarily banners. It is a very aggressive list and not recommended for beginners.",
            homepageUrl:
                "https://zoso.ro/rolist/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇮🇷ir: Persian Blocker",
            downloadUrl:
                "\(partiallyFullUrl)/235_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Filter list for blocking ads and trackers on websites in Persian.",
            homepageUrl:
                "https://github.com/MasterKia/PersianBlocker/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇷🇴ro: road-block light",
            downloadUrl:
                "\(partiallyFullUrl)/236_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Romanian ad blocking filter subscription.",
            homepageUrl:
                "https://github.com/tcptomato/ROad-Block"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇵🇱pl: Polish Annoyances Filters",
            downloadUrl:
                "\(partiallyFullUrl)/237_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Filter list that hides and blocks pop-ups, widgets, newsletters, push notifications, arrows, tagged internal links that are off-topic, and other irritating elements. Polish GDPR-Cookies Filters is already in it.",
            homepageUrl:
                "https://polishannoyancefilters.netlify.app"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇵🇱pl: Polish Anti Adblock Filters",
            downloadUrl:
                "\(partiallyFullUrl)/238_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Official Polish filters against Adblock alerts.",
            homepageUrl:
                "https://github.com/olegwukr/polish-privacy-filters"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇸🇪se: Frellwit's Swedish Filter",
            downloadUrl:
                "\(partiallyFullUrl)/243_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Filter that aims to remove regional Swedish ads, tracking, social media, annoyances, sponsored articles etc.",
            homepageUrl:
                "https://github.com/lassekongo83/Frellwit-s-filter-lists"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇰🇷kr: YousList",
            downloadUrl:
                "\(partiallyFullUrl)/244_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Filter that blocks ads on Korean sites.",
            homepageUrl:
                "https://github.com/yous/YousList/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇵🇱pl: EasyList Polish",
            downloadUrl:
                "\(partiallyFullUrl)/246_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Additional filter list for websites in Polish.",
            homepageUrl:
                "https://github.com/easylistpolish/easylistpolish/"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇵🇱pl: Polish Anti-Annoying Special Supplement",
            downloadUrl:
                "\(partiallyFullUrl)/247_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Filters that block and hide RSS elements and remnants of hidden newsletters combined with social elements on Polish websites.",
            homepageUrl:
                "https://github.com/PolishFiltersTeam/PolishAntiAnnoyingSpecialSupplement"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇳🇴no: Dandelion Sprout's Nordic Filters",
            downloadUrl:
                "\(partiallyFullUrl)/249_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "This list covers websites for Norway, Denmark, Iceland, Danish territories, and the Sami indigenous population.",
            homepageUrl:
                "https://github.com/DandelionSprout/adfilt"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇷🇸rs🇲🇪me🇭🇷hr🇧🇦ba: Dandelion Sprout's Serbo-Croatian List",
            downloadUrl:
                "\(partiallyFullUrl)/252_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "A filter list for websites in Serbian, Montenegrin, Croatian, and Bosnian.",
            homepageUrl:
                "https://github.com/DandelionSprout/adfilt"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇮🇳in: IndianList",
            downloadUrl:
                "\(partiallyFullUrl)/253_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Additional filter list for websites in Hindi, Tamil and other Dravidian and Indic languages.",
            homepageUrl:
                "https://github.com/mediumkreation/IndianList"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "🇲🇰mk: Macedonian adBlock Filters",
            downloadUrl:
                "\(partiallyFullUrl)/254_optimized.txt",
            category: .regional,
            isSelected: false,
            description:
                "Blocks ads and trackers on various Macedonian websites.",
            homepageUrl:
                "https://github.com/DeepSpaceHarbor/Macedonian-adBlock-Filters"
        ),

        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard – Experimental",
            downloadUrl:
                "\(partiallyFullUrl)/5_optimized.txt",
            category: .experimental,
            isSelected: false,
            description:
                "Filter designed to test certain hazardous filtering rules before they are added to the basic filters.",
            homepageUrl:
                "https://github.com/AdguardTeam/AdguardFilters#adguard-filters"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "d3Host List by d3ward",
            downloadUrl:
                "https://raw.githubusercontent.com/d3ward/toolz/master/src/d3host.adblock",
            category: .experimental,
            isSelected: false,
            description:
                "If you want to test WebShield with d3ward's site, enable this filter.",
            homepageUrl: "https://d3ward.github.io/toolz/adblock"
        ),

        FilterListData(
            id: UUID().uuidString,
            name: "ABP Test Pages Filter",
            downloadUrl:
                "https://abptestpages.org/en/abp-testcase-subscription.txt",
            category: .experimental,
            isSelected: false,
            description:
                "Used for internal development for the validation and verification of WebShield's content blocking capabilities. Unless what you know what you're doing, or are told by developers to enable this list for testing, you need not enable it.",
            homepageUrl: "https://abptestpages.org"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard Tests - Element Hiding Rules",
            downloadUrl:
                "https://testcases.agrd.dev/Filters/element-hiding-rules/test-element-hiding-rules.txt",
            category: .experimental,
            isSelected: false,
            description:
                "Used for internal development for the validation and verification of WebShield's content blocking capabilities. Unless what you know what you're doing, or are told by developers to enable this list for testing, you need not enable it.",
            homepageUrl: "https://testcases.agrd.dev"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard Tests - Generic Hiding Rules",
            downloadUrl:
                "https://testcases.agrd.dev/Filters/generichide-rules/generichide-rules.txt",
            category: .experimental,
            isSelected: false,
            description:
                "Used for internal development for the validation and verification of WebShield's content blocking capabilities. Unless what you know what you're doing, or are told by developers to enable this list for testing, you need not enable it.",
            homepageUrl: "https://testcases.agrd.dev"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard Tests - CSS Rules",
            downloadUrl:
                "https://testcases.agrd.dev/Filters/css-rules/css-rules.txt",
            category: .experimental,
            isSelected: false,
            description:
                "Used for internal development for the validation and verification of WebShield's content blocking capabilities. Unless what you know what you're doing, or are told by developers to enable this list for testing, you need not enable it.",
            homepageUrl: "https://testcases.agrd.dev"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard Tests - Extended CSS Rules",
            downloadUrl:
                "https://testcases.agrd.dev/Filters/extended-css-rules/test-extended-css-rules.txt",
            category: .experimental,
            isSelected: false,
            description:
                "Used for internal development for the validation and verification of WebShield's content blocking capabilities. Unless what you know what you're doing, or are told by developers to enable this list for testing, you need not enable it.",
            homepageUrl: "https://testcases.agrd.dev"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard Tests - Extended CSS rules injection into iframe created with js",
            downloadUrl:
                "https://testcases.agrd.dev/Filters/extended-css-rules/extended-css-iframejs-injection/extended-css-iframejs-injection.txt",
            category: .experimental,
            isSelected: false,
            description:
                "Used for internal development for the validation and verification of WebShield's content blocking capabilities. Unless what you know what you're doing, or are told by developers to enable this list for testing, you need not enable it.",
            homepageUrl: "https://testcases.agrd.dev"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard Tests - $important rules",
            downloadUrl:
                "https://testcases.agrd.dev/Filters/important-rules/test-important-rules.txt",
            category: .experimental,
            isSelected: false,
            description:
                "Used for internal development for the validation and verification of WebShield's content blocking capabilities. Unless what you know what you're doing, or are told by developers to enable this list for testing, you need not enable it.",
            homepageUrl: "https://testcases.agrd.dev"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard Tests - WebSocket blocking",
            downloadUrl:
                "https://testcases.agrd.dev/Filters/websockets/test-websockets.txt",
            category: .experimental,
            isSelected: false,
            description:
                "Used for internal development for the validation and verification of WebShield's content blocking capabilities. Unless what you know what you're doing, or are told by developers to enable this list for testing, you need not enable it.",
            homepageUrl: "https://testcases.agrd.dev"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard Tests - Script rules",
            downloadUrl:
                "https://testcases.agrd.dev/Filters/script-rules/test-script-rules.txt",
            category: .experimental,
            isSelected: false,
            description:
                "Used for internal development for the validation and verification of WebShield's content blocking capabilities. Unless what you know what you're doing, or are told by developers to enable this list for testing, you need not enable it.",
            homepageUrl: "https://testcases.agrd.dev"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard Tests - Scriptlet rules",
            downloadUrl:
                "https://testcases.agrd.dev/Filters/scriptlet-rules/test-scriptlet-rules.txt",
            category: .experimental,
            isSelected: false,
            description:
                "Used for internal development for the validation and verification of WebShield's content blocking capabilities. Unless what you know what you're doing, or are told by developers to enable this list for testing, you need not enable it.",
            homepageUrl: "https://testcases.agrd.dev"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard Tests - Popup blocker",
            downloadUrl:
                "https://testcases.agrd.dev/PopupBlocker/test-popup-blocker-rules.txt",
            category: .experimental,
            isSelected: false,
            description:
                "Used for internal development for the validation and verification of WebShield's content blocking capabilities. Unless what you know what you're doing, or are told by developers to enable this list for testing, you need not enable it.",
            homepageUrl: "https://testcases.agrd.dev"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard Tests - $badfilter rules",
            downloadUrl:
                "https://testcases.agrd.dev/Filters/badfilter-rules/test-badfilter-rules.txt",
            category: .experimental,
            isSelected: false,
            description:
                "Used for internal development for the validation and verification of WebShield's content blocking capabilities. Unless what you know what you're doing, or are told by developers to enable this list for testing, you need not enable it.",
            homepageUrl: "https://testcases.agrd.dev"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard Tests - $jsinject rules test",
            downloadUrl:
                "https://testcases.agrd.dev/Filters/script-rules/jsinject-rules/test-jsinject-rules.txt",
            category: .experimental,
            isSelected: false,
            description:
                "Used for internal development for the validation and verification of WebShield's content blocking capabilities. Unless what you know what you're doing, or are told by developers to enable this list for testing, you need not enable it.",
            homepageUrl: "https://testcases.agrd.dev"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard Tests - $denyallow rules",
            downloadUrl:
                "https://testcases.agrd.dev/Filters/denyallow-rules/test-denyallow-rules.txt",
            category: .experimental,
            isSelected: false,
            description:
                "Used for internal development for the validation and verification of WebShield's content blocking capabilities. Unless what you know what you're doing, or are told by developers to enable this list for testing, you need not enable it.",
            homepageUrl: "https://testcases.agrd.dev"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard Tests - $ping,$websocket,$xmlhttprequest rules",
            downloadUrl:
                "https://testcases.agrd.dev/Filters/blocking-request-rules/test-blocking-request-rules.txt",
            category: .experimental,
            isSelected: false,
            description:
                "Used for internal development for the validation and verification of WebShield's content blocking capabilities. Unless what you know what you're doing, or are told by developers to enable this list for testing, you need not enable it.",
            homepageUrl: "https://testcases.agrd.dev"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard Tests - Test $subdocoument rules for Safari 15+",
            downloadUrl:
                "https://testcases.agrd.dev/Filters/subdocument-rules/test-subdocument-rules.txt",
            category: .experimental,
            isSelected: false,
            description:
                "Used for internal development for the validation and verification of WebShield's content blocking capabilities. Unless what you know what you're doing, or are told by developers to enable this list for testing, you need not enable it.",
            homepageUrl: "https://testcases.agrd.dev"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard Tests - Non-basic $path modifier",
            downloadUrl:
                "https://testcases.agrd.dev/Filters/nonbasic-path-modifier/test-nonbasic-path-modifier.txt",
            category: .experimental,
            isSelected: false,
            description:
                "Used for internal development for the validation and verification of WebShield's content blocking capabilities. Unless what you know what you're doing, or are told by developers to enable this list for testing, you need not enable it.",
            homepageUrl: "https://testcases.agrd.dev"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard Tests - $match-case modifier tests",
            downloadUrl:
                "https://testcases.agrd.dev/Filters/match-case-rules/test-match-case-rules.txt",
            category: .experimental,
            isSelected: false,
            description:
                "Used for internal development for the validation and verification of WebShield's content blocking capabilities. Unless what you know what you're doing, or are told by developers to enable this list for testing, you need not enable it.",
            homepageUrl: "https://testcases.agrd.dev"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard Tests - JS and Scriptlet rules: Content Security Policy (CSP) tests",
            downloadUrl:
                "https://testcases.agrd.dev/Filters/content-security-policy/test-content-security-policy.txt",
            category: .experimental,
            isSelected: false,
            description:
                "Used for internal development for the validation and verification of WebShield's content blocking capabilities. Unless what you know what you're doing, or are told by developers to enable this list for testing, you need not enable it.",
            homepageUrl: "https://testcases.agrd.dev"
        ),
        FilterListData(
            id: UUID().uuidString,
            name: "AdGuard Tests - Injection speed tests",
            downloadUrl:
                "https://testcases.agrd.dev/Filters/injection-speed/test-injection-speed.txt",
            category: .experimental,
            isSelected: false,
            description:
                "Used for internal development for the validation and verification of WebShield's content blocking capabilities. Unless what you know what you're doing, or are told by developers to enable this list for testing, you need not enable it.",
            homepageUrl: "https://testcases.agrd.dev"
        ),



    ]

    static func filterListDataById(_ id: String) -> FilterListData? {
        return filterListData.first(where: { $0.id == id })
    }
}

// WebShieldApp/Source/Services/ContentBlockerState.swift
@preconcurrency import SafariServices
import SwiftUI

@MainActor
final class ContentBlockerState: ObservableObject {
    var refreshErrorViewModel: RefreshErrorViewModel
    
    init(refreshErrorViewModel: RefreshErrorViewModel) {
        self.refreshErrorViewModel = refreshErrorViewModel
    }

    // Reload content blocker for a specific category
    func reloadContentBlocker(for category: FilterListCategory) async throws {
        // Skip reloading for the "all" category
        guard category != .all else { return }

        let identifier = "dev.arjuna.WebShield.DeclarativeBlockList-\(category.rawValue)"
        do {
            try await SFContentBlockerManager.reloadContentBlocker(withIdentifier: identifier)
            await WebShieldLogger.shared.log("Content blocker reloaded successfully for category: \(category.rawValue)")
        } catch {
            await handleReloadError(error, for: category)
        }
    }

    // Add a new method to report errors
    private func reportError(title: String, message: String) {
        let error = RefreshError(title: title, message: message, timestamp: Date())
        refreshErrorViewModel.addError(error)
    }

    // Handle errors, now with category
    private func handleReloadError(_ error: Error, for category: FilterListCategory) async {
        let nsError = error as NSError
        await WebShieldLogger.shared.log("ERROR: Failed to reload content blocker for category: \(category.rawValue)")
        await WebShieldLogger.shared.log("Error description: \(nsError.localizedDescription)")
        await WebShieldLogger.shared.log("Error domain: \(nsError.domain)")
        await WebShieldLogger.shared.log("Error code: \(nsError.code)")

        if let underlyingError = nsError.userInfo[NSUnderlyingErrorKey]
            as? NSError
        {
            await WebShieldLogger.shared.log("Underlying error: \(underlyingError)")
        }

        await WebShieldLogger.shared.log("User Info:")
        for (key, value) in nsError.userInfo {
            await WebShieldLogger.shared.log("  \(key): \(value)")
        }

        if nsError.domain == "SFErrorDomain" {
            await handleSFErrorDomain(code: nsError.code, for: category)
        }
    }

    // MARK: - NEW: Check if a content blocker is enabled for a category
    func isContentBlockerEnabled(for category: FilterListCategory) async -> Bool {
        // If category is .all, we might treat it as "not applicable"
        guard category != .all else { return true }

        let identifier = "dev.arjuna.WebShield.DeclarativeBlockList-\(category.rawValue)"

        // Use a continuation to convert completion-handler to async/await
        do {
            return try await SFContentBlockerManager.stateOfContentBlocker(withIdentifier: identifier).isEnabled
        } catch {
            return false
        }
    }

    // Handle SFErrorDomain errors, now with category
    private func handleSFErrorDomain(code: Int, for category: FilterListCategory) async {
        let identifier = "dev.arjuna.WebShield.DeclarativeBlockList-\(category.rawValue)"
        let title = "Content Blocker Error (\(category.rawValue))"
        let message = "Unknown SFErrorDomain error code: \(code)"

        switch code {
        case 1:
            await WebShieldLogger.shared.log(
                "SFErrorDomain error 1: Content Blocker not found or not owned by you."
            )
            await WebShieldLogger.shared.log("Bundle Identifier: \(identifier)")
            await WebShieldLogger.shared.log(
                "Please check JSON validity and file size (max 6MB, 150,000 rules)."
            )
        case 2:
            await WebShieldLogger.shared.log("SFErrorDomain error 2: NSExtensionItem missing attachment.")
        case 3:
            await WebShieldLogger.shared.log(
                "SFErrorDomain error 3: Error loading content blocker extension."
            )
        default:
            await WebShieldLogger.shared.log("Unknown SFErrorDomain error code: \(code)")
        }

        reportError(title: title, message: message)
    }
}

// WebShieldApp/Source/Services/DataManager.swift
import Foundation
import SwiftData

@MainActor
final class DataManager: ObservableObject, Sendable {
    let container: ModelContainer
    private let filterListProcessor = FilterListProcessor()

    init() {
        // Initialize ModelContainer once
        guard
            let groupURL = FileManager.default.containerURL(
                forSecurityApplicationGroupIdentifier: Identifiers.groupID)
        else {
            fatalError("Failed to get container URL for app group.")
        }

        let storeURL = groupURL.appendingPathComponent("Library/Application Support/default.store")
        let config = ModelConfiguration(url: storeURL)

        // Define the schema for your models
        let schema = Schema([FilterList.self])

        // Initialize the container with the schema and configuration
        do {
            container = try ModelContainer(for: schema, configurations: [config])
        } catch {
            fatalError("Failed to initialize ModelContainer: \(error)")
        }
    }

    /// Resets the data model by deleting all records and reseeding.
    func resetModel() async {  // Marked as async
        do {
            // Use await when calling container.mainContext
            try container.mainContext.delete(model: FilterList.self)
            // Call seedData with await
            await seedData()
            await WebShieldLogger.shared.log("Model reset successfully.")
        } catch {
            await WebShieldLogger.shared.log("Failed to reset model: \(error)")
        }
    }

    /// Seeds initial data into the database.
    func seedData() async {

        // For each pre-defined filter list in FilterListProvider:
        for (index, data) in FilterListProvider.filterListData.enumerated() {
            // Use await when calling actor-isolated method
            filterListProcessor.saveFilterList(
                to: container.mainContext,
                id: data.id,
                name: data.name,
                version: "N/A",
                description: data.description,
                category: data.category,
                isEnabled: data.isSelected,
                order: index,
                downloadUrl: data.downloadUrl,
                homepageUrl: data.homepageUrl,
                downloaded: false,
                needsRefresh: true
            )
        }

        // Save the inserted records to SwiftData
        do {
            try container.mainContext.save()
            await WebShieldLogger.shared.log("Seed data saved successfully.")
        } catch {
            await WebShieldLogger.shared.log("Failed to save seed data: \(error)")
        }
    }

    /// Seeds data only if the database is empty.
    func seedDataIfNeeded() async {
        // Use the mainContext from the container
        let context = container.mainContext

        let fetchRequest = FetchDescriptor<FilterList>()
        do {
            let results = try context.fetch(fetchRequest)
            if results.isEmpty {
                // Call seedData with await
                await seedData()
                await WebShieldLogger.shared.log("Seed data inserted.")
            } else {
                await WebShieldLogger.shared.log("Database is not empty.")
            }
        } catch {
            await WebShieldLogger.shared.log("Error fetching or saving data: \(error)")
        }
    }
}

// WebShieldApp/Source/Services/FilterListProcessor.swift
@preconcurrency import ContentBlockerConverter
import Foundation
import OSLog
import SwiftData

/// Processor that downloads, converts, and saves filter lists.
@MainActor
final class FilterListProcessor {
    /// Shared session for downloading.
    let urlSession: URLSession
    /// We can re-use one converter instance or instantiate a new one per list.
    private let converter = ContentBlockerConverter()

    /// Init with a session (default is .shared).
    init(urlSession: URLSession = .shared) {
        self.urlSession = urlSession
    }

    func downloadFilterList(from url: URL) async throws -> (Data, URLResponse) {
        // Use whichever URLSession you have in FilterListProcessor
        let (data, response) = try await urlSession.data(from: url)
        return (data, response)
    }
    // MARK: - Public Main Entry
    /// Downloads, parses, converts a single filter list, then updates the SwiftData model.
    ///
    /// - Parameters:
    ///   - filterList: The SwiftData model object representing this filter
    /// - Returns: A tuple containing `ProcessedConversionResult` and the `FilterListCategory`.
    func processFilterList(
        _ filterList: FilterList
    ) async throws -> (ProcessedConversionResult, FilterListCategory) {  // Return category
        guard let downloadUrl = filterList.downloadUrl,
            let url = URL(string: downloadUrl),
            let category = filterList.category
        else {
            throw NSError(
                domain: "FilterListProcessor", code: 1,
                userInfo: [NSLocalizedDescriptionKey: "Invalid or missing URL or category"])
        }

        // 1. Download raw text
        let (rawText, metadata) = try await downloadAndParseRawText(from: url)

        // 2. Convert with ContentBlockerConverter
        let conversionResult = await convertRules(rawText: rawText)

        // 3. Update SwiftData model fields
        filterList.version = metadata.version
        filterList.homepageUrl = metadata.homepage ?? filterList.homepageUrl
        filterList.standardRuleCount = conversionResult.convertedCount
        filterList.advancedRuleCount = conversionResult.advancedBlockingCount
        filterList.downloaded = true
        filterList.needsRefresh = false
        filterList.lastUpdated = Date()

        // **Remove writing here**
        // Do not write JSON files here

        return (conversionResult, category)  // Return result and category
    }

    // MARK: - Writing the JSON files
    /// Saves the conversion results from all lists into individual category-based JSON files
    /// and a single combined file for advanced rules.
    func saveContentBlockerFiles(
        results: [(ProcessedConversionResult, FilterListCategory)],
        directoryURL: URL
    ) async throws {
        // Group results by category
        let groupedResults = Dictionary(grouping: results, by: { $0.1 })

        // Separate storage for advanced rules
        var allAdvancedRules: [[String: Any]] = []

        // Iterate through each category with enabled filters
        for (category, resultsForCategory) in groupedResults {
            // Skip the "all" category if applicable
            guard category != .all else { continue }

            let fileName = "\(category.rawValue.lowercased()).json"
            let fileURL = directoryURL.appendingPathComponent(fileName)

            // Combine regular rules for this category
            let regularRules = resultsForCategory.compactMap { $0.0.converted }
                .flatMap { jsonString -> [[String: Any]] in
                    if let data = jsonString.data(using: .utf8),
                        let array = try? JSONSerialization.jsonObject(with: data) as? [[String: Any]]
                    {
                        return array
                    }
                    return []
                }

            // Collect advanced rules
            let advancedRules = resultsForCategory.compactMap { $0.0.advancedBlocking }
                .flatMap { jsonString -> [[String: Any]] in
                    if let data = jsonString.data(using: .utf8),
                        let array = try? JSONSerialization.jsonObject(with: data) as? [[String: Any]]
                    {
                        return array
                    }
                    return []
                }
            allAdvancedRules.append(contentsOf: advancedRules)

            // Prepare the final data to write
            let finalData: Data
            if regularRules.isEmpty {
                // Write a minimal rule to signify an empty or default state
                let minimalRule = [
                    [
                        "trigger": [
                            "url-filter": ".*"
                        ],
                        "action": [
                            "type": "ignore-previous-rules"
                        ],
                    ]
                ]
                finalData = try JSONSerialization.data(withJSONObject: minimalRule, options: [])
                await WebShieldLogger.shared.log("Wrote minimal rule to \(fileName)")
            } else {
                finalData = try JSONSerialization.data(withJSONObject: regularRules, options: [])
                await WebShieldLogger.shared.log("Wrote \(regularRules.count) regular rules to \(fileName)")
            }

            // Write to the category-specific JSON file (overwriting any existing content)
            try finalData.write(to: fileURL, options: .atomic)
        }

        // Handle advanced rules
        if allAdvancedRules.isEmpty {
            let emptyData = Data("[]".utf8)
            let advancedURL = directoryURL.appendingPathComponent("advancedBlocking.json")
            try emptyData.write(to: advancedURL, options: .atomic)
            await WebShieldLogger.shared.log("Wrote empty advancedBlocking.json")
        } else {
            let advancedData = try JSONSerialization.data(withJSONObject: allAdvancedRules, options: [])
            let advancedURL = directoryURL.appendingPathComponent("advancedBlocking.json")
            try advancedData.write(to: advancedURL, options: .atomic)
            await WebShieldLogger.shared.log("Wrote \(allAdvancedRules.count) advanced rules to advancedBlocking.json")
        }

        // **Ensure Minimal Rules for Categories Without Enabled Filters**
        // Identify categories not in groupedResults and write minimal rules
        let allCategories = Set(FilterListCategory.allCases).subtracting([.all])
        let categoriesWithFilters = Set(groupedResults.keys).subtracting([.all])
        let categoriesWithoutFilters = allCategories.subtracting(categoriesWithFilters)

        for category in categoriesWithoutFilters {
            let fileName = "\(category.rawValue.lowercased()).json"
            let fileURL = directoryURL.appendingPathComponent(fileName)

            // Prepare minimal rule
            let minimalRule = [
                [
                    "trigger": [
                        "url-filter": ".*"
                    ],
                    "action": [
                        "type": "ignore-previous-rules"
                    ],
                ]
            ]
            let data = try JSONSerialization.data(withJSONObject: minimalRule, options: [])
            try data.write(to: fileURL, options: .atomic)
            await WebShieldLogger.shared.log("Wrote minimal rule to \(fileName) for disabled category")
        }
    }

    /// Saves the converted rules as JSON for a given category, if not `.all`.
    /// Writes an empty `[]` file if rules are missing or cannot be parsed.
    func saveContentBlockerFile(
        result: ProcessedConversionResult,
        category: FilterListCategory,
        directoryURL: URL
    ) async throws {
        // Skip if category is "all"
        guard category != .all else { return }

        let fileURL = directoryURL.appendingPathComponent("\(category.rawValue.lowercased()).json")

        // Obtain the raw converted JSON
        guard let rawJSON = result.converted,
            let data = rawJSON.data(using: .utf8)
        else {
            // If there's no valid JSON, write a minimal rule
            try writeMinimalRule(to: fileURL)
            await WebShieldLogger.shared.log("Wrote minimal \(fileURL.lastPathComponent)")
            return
        }

        // Parse the JSON into an array of dictionaries
        guard let rules = try? JSONSerialization.jsonObject(with: data) as? [[String: Any]] else {
            // If parsing fails, write a minimal rule
            try writeMinimalRule(to: fileURL)
            await WebShieldLogger.shared.log("Wrote minimal \(fileURL.lastPathComponent)")
            return
        }

        // Prepare the final data to write
        let finalData: Data
        if rules.isEmpty {
            // Write a minimal rule to signify an empty or default state
            let minimalRule = [
                [
                    "trigger": [
                        "url-filter": ".*"
                    ],
                    "action": [
                        "type": "ignore-previous-rules"
                    ],
                ]
            ]
            finalData = try JSONSerialization.data(withJSONObject: minimalRule, options: [])
            await WebShieldLogger.shared.log("Wrote minimal \(fileURL.lastPathComponent)")
        } else {
            finalData = try JSONSerialization.data(withJSONObject: rules, options: [])
            await WebShieldLogger.shared.log("Wrote \(rules.count) regular rules to \(fileURL.lastPathComponent)")
        }

        // Write to the category-specific JSON file (overwriting any existing content)
        try finalData.write(to: fileURL, options: .atomic)
    }

    // Helper Method to Write Minimal Rule
    private func writeMinimalRule(to fileURL: URL) throws {
        let minimalRule = [
            [
                "trigger": [
                    "url-filter": ".*"
                ],
                "action": [
                    "type": "ignore-previous-rules"
                ],
            ]
        ]
        let data = try JSONSerialization.data(withJSONObject: minimalRule, options: [])
        try data.write(to: fileURL, options: .atomic)
    }

    private func writeEmptyJSON(to fileURL: URL) throws {
        let empty = Data("[]".utf8)
        try empty.write(to: fileURL, options: .atomic)
    }

    // MARK: - Private Helpers

    /// Downloads the data from the URL and parses for metadata (version, homepage).
    private func downloadAndParseRawText(from url: URL) async throws -> (String, ParsedMetadata) {
        let (data, response) = try await urlSession.data(from: url)

        guard
            let httpResponse = response as? HTTPURLResponse,
            httpResponse.statusCode == 200,
            let rawText = String(data: data, encoding: .utf8)
        else {
            throw FilterListError.invalidServerResponse
        }

        let metadata = parseMetadata(from: rawText)
        return (rawText, metadata)
    }

    /// Parse lines like `! Version:` or `! Homepage:` from the raw text.
    private func parseMetadata(from content: String) -> ParsedMetadata {
        var version = "1.0.0"
        var homepage: String?

        // Split once, iterate line by line
        for line in content.split(whereSeparator: \.isNewline) {
            // ! Version:
            if line.hasPrefix("! Version:") {
                let newVersion =
                    line
                    .dropFirst("! Version:".count)
                    .trimmingCharacters(in: .whitespacesAndNewlines)
                if !newVersion.isEmpty {
                    version = newVersion
                }
            }
            // ! Homepage:
            else if line.hasPrefix("! Homepage:") {
                let newHomepage =
                    line
                    .dropFirst("! Homepage:".count)
                    .trimmingCharacters(in: .whitespacesAndNewlines)
                if !newHomepage.isEmpty {
                    homepage = newHomepage
                }
            }

            // If we’ve found both, no need to keep scanning
            if homepage != nil, version != "1.0.0" {
                break
            }
        }

        return ParsedMetadata(version: version, homepage: homepage)
    }

    /// Converts lines using `ContentBlockerConverter`.
    /// Returns a `ProcessedConversionResult` with separate "converted" JSON and "advancedBlocking" JSON.
    private func convertRules(rawText: String) async -> ProcessedConversionResult {
        // 1. Prepare rules in a single pass
        let filteredRules = rawText.split(whereSeparator: \.isNewline).compactMap { line -> String? in
            let trimmed = line.trimmingCharacters(in: .whitespacesAndNewlines)
            guard !trimmed.isEmpty, !trimmed.hasPrefix("!") else {
                return nil
            }
            return trimmed
        }

        // 2. Convert using ContentBlockerConverter
        let result = converter.convertArray(
            rules: filteredRules,
            safariVersion: .safari16_4,
            optimize: true,
            advancedBlocking: true,
            advancedBlockingFormat: .json
        )

        // 3. Count advanced rules if present
        let advancedCount =
            result.advancedBlocking
            .flatMap { $0.data(using: .utf8) }
            .flatMap { try? JSONSerialization.jsonObject(with: $0) as? [Any] }?.count ?? 0

        // 4. Return processed result
        return ProcessedConversionResult(
            converted: result.converted,
            advancedBlocking: result.advancedBlocking,
            convertedCount: result.convertedCount,
            advancedBlockingCount: advancedCount,
            errorsCount: result.errorsCount,
            overLimit: result.overLimit,
            message: result.message
        )
    }

    func saveFilterList(
        to context: ModelContext,
        id: String,
        name: String,
        version: String,
        description: String,
        category: FilterListCategory,
        isEnabled: Bool,
        order: Int,
        downloadUrl: String? = nil,
        homepageUrl: String? = nil,
        downloaded: Bool,
        needsRefresh: Bool
    ) {
        // 1. Fetch if it already exists
        let fetchDescriptor = FetchDescriptor<FilterList>(
            predicate: #Predicate { $0.id == id }
        )

        if let existing = try? context.fetch(fetchDescriptor).first {
            // 2a. Update it
            existing.name = name
            existing.version = version
            existing.desc = description
            existing.categoryString = category.rawValue
            existing.isEnabled = isEnabled
            existing.order = order
            existing.downloaded = downloaded
            existing.needsRefresh = needsRefresh
            if let sourceUrl = downloadUrl, !sourceUrl.isEmpty {
                existing.downloadUrl = sourceUrl
            }
            if let homepage = homepageUrl, !homepage.isEmpty {
                existing.homepageUrl = homepage
            }
        } else {
            // 2b. Create a new one
            let newFilterList = FilterList(
                name: name,
                version: version,
                desc: description,
                category: category,
                isEnabled: isEnabled,
                order: order,
                downloadUrl: downloadUrl,
                homepageUrl: homepageUrl,
                downloaded: downloaded,
                needsRefresh: needsRefresh
            )
            newFilterList.id = id  // if FilterList has an `id` property
            context.insert(newFilterList)
        }
    }

}

// WebShieldApp/Source/Services/WebExtensionState.swift
import SafariServices

@MainActor
final class WebExtensionState: ObservableObject {
    private let advancedExtensionIdentifier = "dev.arjuna.WebShield.Advanced"
    
    func isAdvancedExtensionEnabled() async -> Bool {
        #if os(macOS)
        do {
            return try await SFSafariExtensionManager.stateOfSafariExtension(
                withIdentifier: advancedExtensionIdentifier
            ).isEnabled
        } catch {
            return false
        }
        #elseif os(iOS) || os(visionOS)
        return true
        #endif
    }
}

// WebShieldApp/Source/Services/WebShieldLogger.swift
import Foundation
import os

/// A simple, concurrency-safe logger for in-app text logs.
public actor WebShieldLogger {

    /// Keep a ring buffer or simple array for logs.
    /// Here we just append and trim to the last 1000 entries.
    private var logs: [String] = []

    /// Single shared instance (a “global” with minimal side effects).
    public static let shared = WebShieldLogger()

    /// Limit the maximum number of lines we store in memory.
    private let maxEntries = 1000

    /// Private initializer to enforce singleton usage.
    private init() {}

    // MARK: - Public API

    /// Appends a new line to the in-memory logs (and trims older entries).
    /// Also prints to the console for convenience.
    public func log(_ message: String) {
        let timestamp = Self.currentTimestamp()
        logs.append("[\(timestamp)] \(message)")

        // Keep memory usage bounded to maxEntries
        if logs.count > maxEntries {
            logs.removeFirst(logs.count - maxEntries)
        }

        // For development convenience, also log to console
        print(message)
    }

    /// Retrieves all logged lines.
    /// - Returns: An array of all log messages in chronological order.
    public func allLogs() -> [String] {
        logs
    }
    
    public func clearLogs() {
        logs.removeAll()
        log("Logs cleared.") // Optionally, log the action itself
    }

    // MARK: - Specialized Logging Methods

    /// Logs a simple timestamped step message (like “Processing,” etc.).
    public func logFilterListProcessingStep(_ step: String, for listName: String) {
        self.log("\(listName): \(step)")
    }

    /// Logs the start of a refresh event with a blank line for clarity.
    public func logRefreshStart() {
        self.log("\n\nSTARTING REFRESH\n")
    }

    /// Logs general “conversion statistics,” similar to your original code.
    public func logConversionStatistics(
        totalConvertedCount: Int,
        convertedCount: Int,
        errorsCount: Int,
        overLimit: Bool,
        for listName: String
    ) {
        self.log(
            """
            Conversion statistics for \(listName):
            - Total converted count: \(totalConvertedCount)
            - Converted count: \(convertedCount)
            - Errors count: \(errorsCount)
            - Over limit: \(overLimit)
            """)
    }

    /// Logs aggregated stats across multiple lists or processes.
    public func logTotalStatistics(_ stats: TotalStats) {
        self.log(
            """
            Total conversion statistics:
            - Total converted count: \(stats.totalConvertedCount)
            - Converted count: \(stats.convertedCount)
            - Errors count: \(stats.errorsCount)
            - Lists over limit: \(stats.overLimit)
            """)
    }

    // MARK: - Helper

    /// Generates a time-only (HH:mm:ss) localized timestamp.
    private static func currentTimestamp() -> String {
        let now = Date()
        return DateFormatter.localizedString(from: now, dateStyle: .none, timeStyle: .medium)
    }
}

// WebShieldApp/Source/ViewModels/ExtensionCheckViewModel.swift
import SafariServices
import SwiftUI

@MainActor
final class ExtensionCheckViewModel: ObservableObject {
    // Dependencies
    private let contentBlockerState: ContentBlockerState
    private let advancedExtensionState: WebExtensionState
    // Possibly another actor for advanced extension checks

    // Published state for UI
    @Published var missingExtensions: [String] = []
    @Published var showEnablePrompt = false

    init(contentBlockerState: ContentBlockerState, advancedExtensionState: WebExtensionState) {
        self.contentBlockerState = contentBlockerState
        self.advancedExtensionState = advancedExtensionState
    }

    func checkExtensions() async {
        missingExtensions.removeAll()
        showEnablePrompt = false

        // Check all content blockers
        for category in FilterListCategory.allCases where category != .all {
            let isEnabled = await contentBlockerState.isContentBlockerEnabled(for: category)
                        await WebShieldLogger.shared.log("Content Blocker for \(category.rawValue) is enabled: \(isEnabled)")
            if !isEnabled {
                missingExtensions.append("WebShield \(category.rawValue)")
            }
        }

        // Check advanced extension
        let advancedEnabled = await advancedExtensionState.isAdvancedExtensionEnabled()
                    await WebShieldLogger.shared.log("Advanced (Web)Extension is enabled: \(advancedEnabled)")
        if !advancedEnabled {
            missingExtensions.append("WebShield Advanced")
        }

        // Show prompt only if something’s disabled
        showEnablePrompt = !missingExtensions.isEmpty
    }
}

// WebShieldApp/Source/ViewModels/RefreshErrorViewModel.swift
import SwiftUI

struct RefreshError: Identifiable, Equatable { // Equatable to remove duplicates
    let id = UUID() // Automatic unique identifier
    let title: String
    let message: String
    let timestamp: Date
    
        // Static method for creating localized error descriptions
    static func localizedError(for error: Error, in listName: String) -> RefreshError {
        let title = "Error in \(listName)"
        let message: String
        
        switch error {
            case FilterListError.invalidURL:
                message = NSLocalizedString("The provided URL is not valid.", comment: "Invalid URL error")
            case FilterListError.invalidData:
                message = NSLocalizedString("Invalid filter list data.", comment: "Invalid data error")
            case FilterListError.invalidFormat:
                message = NSLocalizedString("Invalid filter list format.", comment: "Invalid format error")
            case FilterListError.downloadFailed:
                message = NSLocalizedString("Failed to download filter list.", comment: "Download failed error")
            case FilterListError.parsingFailed:
                message = NSLocalizedString("Failed to parse filter list.", comment: "Parsing failed error")
            case FilterListError.invalidServerResponse:
                message = NSLocalizedString("Failed to receive filter list due to invalid server response.", comment: "Invalid server response error")
            default:
                message = NSLocalizedString("An unexpected error occurred.", comment: "Unexpected error")
        }
        
        return RefreshError(title: title, message: message, timestamp: Date())
    }
    
        // Consider adding an initializer from NSError if needed
}

enum RefreshState {
    case idle
    case refreshing
    case success
    case failed([RefreshError]) // Store the errors if it failed
}

@MainActor
class RefreshErrorViewModel: ObservableObject {
    @Published var errors: [RefreshError] = []
    @Published var showErrorView: Bool = false // Flag to show/hide the ErrorView
    
        // Clear errors
    func clearErrors() {
        errors.removeAll()
        showErrorView = false // Also hide the view when clearing
    }
    
        // Add an error
    func addError(_ error: RefreshError) {
        if !errors.contains(error) {
            errors.append(error)
        }
    }
}

// WebShieldApp/Source/Views/ContentView/ContentView.swift
import Foundation
import SafariServices
import SwiftData
import SwiftUI

struct ContentView: View {
    @Environment(\.modelContext) private var modelContext
    @Query(sort: \FilterList.order, order: .forward) private var filterLists: [FilterList]
    @State private var selectedCategory: FilterListCategory? = .all
    @State private var isUpdating = false
    @State private var showingLogs = false
    @State private var showingImport = false
    @State private var showingSettings = false
    @State private var progress: Double = 0
    @State private var currentList: Int = 0
    private let filterListProcessor = FilterListProcessor()
    @State private var totalLists: Int = 0
    @State private var columnVisibility = NavigationSplitViewVisibility.automatic
    @EnvironmentObject private var contentBlockerState: ContentBlockerState
    @EnvironmentObject private var advancedExtensionState: WebExtensionState
    @EnvironmentObject private var refreshErrorViewModel: RefreshErrorViewModel
    @StateObject private var extensionVM: ExtensionCheckViewModel

    init(contentBlockerState: ContentBlockerState? = nil, advancedExtensionState: WebExtensionState? = nil) {
        let refreshErrorViewModel = RefreshErrorViewModel()
        _extensionVM = StateObject(
            wrappedValue: ExtensionCheckViewModel(
                contentBlockerState: contentBlockerState ?? ContentBlockerState(
                    refreshErrorViewModel: refreshErrorViewModel),
                advancedExtensionState: advancedExtensionState ?? WebExtensionState()
            )
)
    }

    var body: some View {
        NavigationSplitView(columnVisibility: $columnVisibility) {
            SidebarView(selectedCategory: $selectedCategory)
        } detail: {
            detailView
        }
        .onAppear {
            Task {
                await extensionVM.checkExtensions()
            }
        }
        .sheet(isPresented: $extensionVM.showEnablePrompt) {
            EnableExtensionsSheet(missingExtensions: extensionVM.missingExtensions)
        }

    }

    private var detailView: some View {
        VStack(alignment: .leading, spacing: 0) {
            if isUpdating {
                ProgressView(value: progress, total: 1.0)
                    .progressViewStyle(.linear)
                    .tint(.blue)
            }

            FilterListView(category: selectedCategory ?? .all)
                .navigationTitle(selectedCategory?.rawValue ?? "All")
                .toolbar {
                    toolbarContent()
                }
                .sheet(isPresented: $showingLogs) {
                    LogsView()
                }
                .sheet(isPresented: $showingImport) {
                    ImportView()
                }
                .sheet(isPresented: $showingSettings) {
                    SettingsView()
                }
                .sheet(isPresented: $refreshErrorViewModel.showErrorView) {
                    ErrorView()
                        .environmentObject(refreshErrorViewModel)
                }

        }
    }

    @ToolbarContentBuilder
    private func toolbarContent() -> some ToolbarContent {
        ToolbarItemGroup(placement: .automatic) {
            Button(action: { showingSettings.toggle() }) {
                Label("Settings", systemImage: "gear")
            }
            .help("Settings")

            //            PulsatingCircleButton()

            Button(action: { refreshFilters() }) {
                Label("Refresh", systemImage: "arrow.2.circlepath")
            }
            .help("Refresh Filters")
            .disabled(isUpdating)

            Button(action: { showingLogs.toggle() }) {
                Label("Logs", systemImage: "doc.text.magnifyingglass")
            }
            .help("View Logs")

            Button(action: { showingImport.toggle() }) {
                Label("Import", systemImage: "plus")
            }
            .help("Import Filters")
        }
    }

    private var enabledFilterCount: Int {
        filterLists.filter { $0.isEnabled }.count
    }

    /// Summation of counts from both blockerList.json and advancedBlocking.json.
    private var totalRuleCount: Int {
        var combinedCount = 0

        // 1. blockerList.json
        if let blockerListURL = GroupContainerURL.groupContainerURL()?
            .appendingPathComponent("blockerList.json")
        {
            combinedCount += jsonArrayCount(at: blockerListURL)
        }

        // 2. advancedBlocking.json
        if let advancedBlockingURL = GroupContainerURL.groupContainerURL()?
            .appendingPathComponent("advancedBlocking.json")
        {
            combinedCount += jsonArrayCount(at: advancedBlockingURL)
        }

        return combinedCount
    }

    /// Safely decodes a file as a top-level JSON array, then returns its count.
    /// If the file is missing or invalid, returns 0.
    private func jsonArrayCount(at fileURL: URL) -> Int {
        guard
            let data = try? Data(contentsOf: fileURL),
            let jsonObject = try? JSONSerialization.jsonObject(with: data),
            let array = jsonObject as? [Any]
        else {
            return 0
        }
        return array.count
    }

    private func shouldShowSection(_ category: FilterListCategory) -> Bool {
        selectedCategory == .all || category == selectedCategory
    }

    private var groupedFilterLists: [FilterListSection] {
        let categoryOrder: [FilterListCategory] = [
            .ads, .privacy, .security, .multipurpose,
            .social, .cookies, .annoyances, .regional,
            .experimental, .custom,
        ]

        let sortedLists = filterLists.sorted { $0.order < $1.order }
        var sections: [FilterListCategory: [FilterList]] = [:]

        for list in sortedLists {
            if let category = list.category {
                sections[category, default: []].append(list)
            }
        }

        return categoryOrder.compactMap { category in
            if let lists = sections[category], !lists.isEmpty {
                return FilterListSection(
                    title: category.rawValue,
                    filterLists: lists,
                    category: category
                )
            }
            return nil
        }
    }

    func refreshFilters() {
        Task {
            // Log & set up UI state
            refreshErrorViewModel.clearErrors()

            await WebShieldLogger.shared.logRefreshStart()
            isUpdating = true
            progress = 0
            currentList = 0

            var refreshErrors: [RefreshError] = []

            defer {
                isUpdating = false
                progress = 0
                currentList = 0
                totalLists = 0
                // Determine and set the final refresh state
                // Show error view only if errors occurred
                if !refreshErrors.isEmpty {
                    refreshErrorViewModel.errors = refreshErrors
                    refreshErrorViewModel.showErrorView = true  // Signal to show ErrorView
                }

            }

            // 1. Fetch all enabled filter lists
            let fetchDescriptor = FetchDescriptor<FilterList>(
                predicate: #Predicate { $0.isEnabled == true }
            )
            guard let enabledLists = try? modelContext.fetch(fetchDescriptor) else {
                await WebShieldLogger.shared.logFilterListProcessingStep(
                    "Failed to fetch enabled filter lists", for: "System")
                return
            }

            totalLists = enabledLists.count

            // 2. If no filters at all, handle empty across every category
            if totalLists == 0 {
                await WebShieldLogger.shared.logFilterListProcessingStep(
                    "No filters are enabled; writing empty blocklist for each category.",
                    for: "Refresh"
                )
                await writeEmptyBlockersForAllCategories()

                // Reload all content blockers
                for category in FilterListCategory.allCases where category != .all {
                    try await contentBlockerState.reloadContentBlocker(for: category)
                }

                AppSettings.shared.hasPerformedInitialRefresh = true
                AppSettings.shared.lastRefreshedEnabledFilters =
                    filterLists
                    .filter { $0.isEnabled }
                    .map { $0.id }
                    .reduce(into: Set<String>()) { $0.insert($1) }

                return
            }

            // 3. Process each filter list and collect results by category
            var resultsByCategory: [FilterListCategory: [ProcessedConversionResult]] = [:]
            for (index, filterList) in enabledLists.enumerated() {
                do {
                    let (result, category) = try await filterListProcessor.processFilterList(filterList)
                    resultsByCategory[category, default: []].append(result)

                    // Update progress
                    currentList = index + 1
                    progress = Double(currentList) / Double(totalLists)
                } catch {
                    await WebShieldLogger.shared.logFilterListProcessingStep(
                        "Failed to process \(filterList.name): \(error.localizedDescription)",
                        for: filterList.name
                    )
                    // Decide whether to return immediately or continue processing the rest
                    // Add error to the ViewModel
                    let refreshError = RefreshError.localizedError(for: error, in: filterList.name)
                    refreshErrors.append(refreshError)

                }
            }

            // 4. Aggregate all results into a single list
            var combinedResults: [(ProcessedConversionResult, FilterListCategory)] = []
            for (category, results) in resultsByCategory {
                combinedResults.append(contentsOf: results.map { ($0, category) })
            }

            // 5. Write all category JSON files once
            do {
                guard let groupURL = GroupContainerURL.groupContainerURL() else {
                    await WebShieldLogger.shared
                        .logFilterListProcessingStep("Could not find App Group container URL.", for: "System")
                    return
                }

                // Save all content blocker files at once
                try await filterListProcessor.saveContentBlockerFiles(
                    results: combinedResults,
                    directoryURL: groupURL
                )

                // Reload all content blockers
                for category in FilterListCategory.allCases where category != .all {
                    try await contentBlockerState.reloadContentBlocker(for: category)
                }

                // Persist changes to SwiftData
                await WebShieldLogger.shared.log("Saving Model")
                try modelContext.save()

                AppSettings.shared.hasPerformedInitialRefresh = true

                // Reset needsRefresh for all filter lists
                for list in filterLists {
                    list.needsRefresh = false
                }

                AppSettings.shared.hasPerformedInitialRefresh = true  // Mark initial refresh as complete
                AppSettings.shared.lastRefreshedEnabledFilters =
                    filterLists
                    .filter { $0.isEnabled }
                    .map { $0.id }
                    .reduce(into: Set<String>()) { $0.insert($1) }
            } catch {
                await WebShieldLogger.shared.log("Failed to save content blocker files: \(error)")
            }
        }
    }

    /// Returns a minimal “do-nothing” content-blocker rule as JSON.
    private func minimalRuleJSON() -> String {
        """
        [
          {
            "trigger": {
              "url-filter": ".*"
            },
            "action": {
              "type": "ignore-previous-rules"
            }
          }
        ]
        """
    }

    // MARK: - Helper: Write empty JSON for all categories
    private func writeEmptyBlockersForAllCategories() async {
        do {
            guard let groupURL = GroupContainerURL.groupContainerURL() else { return }

            // Write minimal rule for each category except .all
            for category in FilterListCategory.allCases where category != .all {
                let fileName = "\(category.rawValue.lowercased()).json"
                let fileURL = groupURL.appendingPathComponent(fileName)

                // Prepare minimal rule
                let minimalRule = [
                    [
                        "trigger": [
                            "url-filter": ".*"
                        ],
                        "action": [
                            "type": "ignore-previous-rules"
                        ],
                    ]
                ]
                let data = try JSONSerialization.data(withJSONObject: minimalRule, options: [])
                try data.write(to: fileURL, options: .atomic)
                await WebShieldLogger.shared.log("Wrote minimal rule to \(fileName)")
            }

            // Overwrite advancedBlocking.json with empty array
            let advancedBlockingURL = groupURL.appendingPathComponent("advancedBlocking.json")
            try Data("[]".utf8).write(to: advancedBlockingURL, options: .atomic)
            await WebShieldLogger.shared.log("Wrote empty advancedBlocking.json")

        } catch {
            await WebShieldLogger.shared.log("Failed to handle empty filters: \(error)")
        }
    }
    // MARK: - Helper: Write empty JSON for a single category
    private func writeEmptyBlocker(for category: FilterListCategory, at directoryURL: URL) async throws {
        let emptyResult = ProcessedConversionResult(
            converted: minimalRuleJSON(),
            advancedBlocking: nil,
            convertedCount: 0,
            advancedBlockingCount: 0,
            errorsCount: 0,
            overLimit: false,
            message: nil
        )
        try await filterListProcessor.saveContentBlockerFile(
            result: emptyResult,
            category: category,
            directoryURL: directoryURL
        )
        await WebShieldLogger.shared.log("Wrote empty \(category.rawValue.lowercased()).json")
    }

}

#Preview {
    @Previewable var dataManager = DataManager()
    ContentView()
        .modelContainer(dataManager.container)
        .environmentObject(dataManager)
        .onAppear {
            Task {
                await dataManager.seedDataIfNeeded()
            }
        }
}

// WebShieldApp/Source/Views/ContentView/FilterListRow.swift
import SwiftData
import SwiftUI

struct FilterListRow: View {
    let filterList: FilterList
    @Environment(\.openURL) private var openURL
    @Environment(\.modelContext) private var modelContext

    private var providerData: FilterListData? {
        FilterListProvider.filterListData.first { $0.name == filterList.name }
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack(alignment: .center, spacing: 0) {
                Text(filterList.name)
                    .font(.headline)
                Spacer()
                Toggle(
                    "Enable Filter",
                    isOn: Binding(
                        get: { filterList.isEnabled },
                        set: { newValue in
                            filterList.isEnabled = newValue
                            filterList.needsRefresh = true
                            try? modelContext.save()
                        }
                    )
                )
                .toggleStyle(.switch)
                .labelsHidden()
            }
            actionButtons()

            Text(filterList.desc)
                .font(.subheadline)
                .foregroundStyle(.secondary)

            footerInfo()

        }
        .padding(.vertical, 8)
    }

    @ViewBuilder
    private func footerInfo() -> some View {
        if filterList.downloaded {
            Text("\(filterList.totalRuleCount) rules")
                .font(.footnote)
                .foregroundStyle(.secondary)

            Text("Version: \(filterList.version)")
                .font(.footnote)
                .foregroundStyle(.secondary)

            Text("Last Updated: \(filterList.lastUpdated, formatter: itemFormatter)")
                .font(.footnote)
                .foregroundStyle(.secondary)
        } else {
            Text("Never Downloaded!")
                .font(.footnote)
                .foregroundStyle(.secondary)
            Text("Never Updated!")
                .font(.footnote)
                .foregroundStyle(.secondary)

        }
    }

    @ViewBuilder
    private func actionButtons() -> some View {
        HStack(spacing: 8) {
            if let homepage = filterList.homepageUrl, let url = URL(string: homepage) {
                createButton(url: url, systemImage: "house", helpText: "Open Homepage")
            }

            if let downloadUrl = (providerData?.downloadUrl ?? filterList.downloadUrl), let url = URL(string: downloadUrl) {
                createButton(url: url, systemImage: "eye", helpText: "View Filter Source")
            }

            if let infoURL = providerData?.informationUrl, let url = URL(string: infoURL) {
                createButton(url: url, systemImage: "info.circle", helpText: "View Filter Information")
            }
        }
    }

    private let itemFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .short
        return formatter
    }()

    @ViewBuilder
    private func createButton(url: URL, systemImage: String, helpText: String) -> some View {
        Button {
            openURL(url)
        } label: {
            Label(helpText, systemImage: systemImage)
                .labelStyle(.iconOnly)
            //                .foregroundStyle(.secondary)
        }
        .buttonStyle(.borderless)
        .help(helpText)
    }
}

// WebShieldApp/Source/Views/ContentView/FilterListView.swift
import SwiftData
import SwiftUI

struct FilterListView: View {
    var category: FilterListCategory
    @Query(sort: \FilterList.order, order: .forward) private var filterLists: [FilterList]
    @Environment(\.modelContext) private var modelContext
    @State private var searchText: String = ""

    var body: some View {
        List {
            let filteredLists = getFilteredLists()

            if !filteredLists.isEmpty {
                StatsView(filteredLists: filteredLists)
            }

            let groupedLists = getGroupedFilterLists(filteredLists: filteredLists)
            ForEach(groupedLists, id: \.id) { section in
                filterListSectionView(section: section)
            }
        }
        .listStyle(.automatic)
        .searchable(text: $searchText)
    }

    // MARK: - Helper Methods

    private func getFilteredLists() -> [FilterList] {
        filterLists.filter { filterList in
            let categoryMatches = (category == .all || filterList.category == category)

            let searchTextLowercased = searchText.lowercased()
            let nameMatches = searchText.isEmpty || filterList.name.lowercased().contains(searchTextLowercased)
            let descMatches = searchText.isEmpty || filterList.desc.lowercased().contains(searchTextLowercased)

            return categoryMatches && (nameMatches || descMatches)
        }
    }

    private func getGroupedFilterLists(filteredLists: [FilterList]) -> [FilterListSection] {
        let sortedLists = filteredLists.sorted { $0.order < $1.order }
        var sections: [FilterListCategory: [FilterList]] = [:]

        for list in sortedLists {
            if let category = list.category {
                sections[category, default: []].append(list)
            }
        }

        let categoryOrder: [FilterListCategory] = [
            .ads, .privacy, .security, .multipurpose, .social,
            .cookies, .annoyances, .regional, .experimental,
        ]

        var orderedSections = categoryOrder.compactMap { category in
            if let lists = sections[category], !lists.isEmpty {
                return FilterListSection(title: category.rawValue, filterLists: lists, category: category)
            }
            return nil
        }

        if let customLists = sections[.custom], !customLists.isEmpty {
            orderedSections.append(
                FilterListSection(
                    title: FilterListCategory.custom.rawValue,
                    filterLists: customLists,
                    category: .custom
                )
            )
        }

        return orderedSections
    }

    @ViewBuilder
    private func filterListSectionView(section: FilterListSection) -> some View {
        Section(header: Text(section.title).font(.headline).textCase(.none)) {
            ForEach(section.filterLists) { filterList in
                filterListRowView(filterList: filterList)
            }
        }
    }

    @ViewBuilder
    private func filterListRowView(filterList: FilterList) -> some View {
        FilterListRow(filterList: filterList)
            .swipeActions(edge: .trailing, allowsFullSwipe: true) {
                if filterList.category == .custom {
                    Button(role: .destructive) {
                        withAnimation {
                            _ = Task<Void, Never> {
                                await deleteFilterList(filterList)
                            }
                        }
                    } label: {
                        Label("Delete", systemImage: "trash")
                    }
                }
            }
            .padding()
    }

    @MainActor
    private func deleteFilterList(_ filterList: FilterList) async {
        modelContext.delete(filterList)
        do {
            try modelContext.save()
        } catch {
            await WebShieldLogger.shared.log("Failed to delete filter list: \(error)")
        }
    }
}

// WebShieldApp/Source/Views/ContentView/StatsView.swift
//
//  StatsView.swift
//  WebShield
//
//  Created by Arjun on 1/11/25.
//

import Foundation
import SwiftData
import SwiftUI

struct StatsView: View {
    @Query(sort: \FilterList.order, order: .forward) private var filterLists: [FilterList]
    var filteredLists: [FilterList]

    var body: some View {
        Section {
            HStack {
                // Shield
                ZStack {
                    RoundedRectangle(cornerRadius: 8)
                        .fill(.blue.opacity(0.15))
                        .frame(width: 36, height: 36)

                    Image(systemName: "shield")
                        .imageScale(.medium)
                        .foregroundStyle(.blue)
                        .fontWeight(.semibold)
                }

                Grid(horizontalSpacing: 10, verticalSpacing: 4) {
                    GridRow {
                        Text("\(enabledCount)")
                            .font(.title2)
                            .bold()
                            .gridColumnAlignment(.leading)
                        Text("\(totalRules)")
                            .font(.title2)
                            .bold()
                            .gridColumnAlignment(.leading)
                    }
                    GridRow {
                        Text("Enabled")
                            .font(.subheadline)
                            .foregroundStyle(.secondary)
                            .gridColumnAlignment(.leading)
                        Text("Rules")
                            .font(.subheadline)
                            .foregroundStyle(.secondary)
                            .gridColumnAlignment(.leading)
                    }
                }
                .padding()

                Spacer()
            }
        }

    }

    private var enabledCount: Int {
        filteredLists.filter { $0.isEnabled }.count
    }

    private var totalRules: Int {
        filteredLists.filter { $0.isEnabled }.reduce(0) {
            $0 + $1.totalRuleCount
        }
    }
}

// WebShieldApp/Source/Views/Error/ErrorView.swift
import SwiftUI

struct ErrorView: View {
    @EnvironmentObject var refreshErrorViewModel: RefreshErrorViewModel
    @Environment(\.dismiss) var dismiss

    var body: some View {
        NavigationStack {
            VStack(spacing: 20) {
                Image(systemName: "exclamationmark.triangle.fill")
                    .font(.system(size: 60, weight: .regular))
                    .foregroundColor(.orange)
                    .padding(.top, 32)
                    .symbolEffect(.bounce, value: refreshErrorViewModel.errors)

                VStack(spacing: 8) {
                    Text("Refresh Failed")
                        .font(.largeTitle)
                        .fontWeight(.bold)
                        .multilineTextAlignment(.center)

                    Text("Some filter lists could not be updated")
                        .font(.headline)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                }

                ScrollView {
                    VStack(alignment: .leading, spacing: 12) {
                        ForEach(refreshErrorViewModel.errors) { error in
                            VStack(alignment: .leading, spacing: 4) {
                                Text(error.title)
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                Text(error.message)
                                    .font(.subheadline)
                                    .foregroundColor(.secondary)
                            }
                            .padding(.vertical, 8)
                            .frame(maxWidth: .infinity, alignment: .leading)
                        }
                    }
                    .padding(.horizontal)
                }

                Spacer()

                Button(action: {
                    refreshErrorViewModel.showErrorView = false
                    dismiss()
                }) {
                    Text("Try Again")
                        .font(.headline)
                        .frame(maxWidth: .infinity)
                        .padding()
                }
                .buttonStyle(.borderedProminent)
                .padding(.horizontal)
                .padding(.bottom, 24)
            }
            .padding()
            .navigationTitle("Error Details")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Dismiss") {
                        dismiss()
                    }
                }
            }
        }
    }
}

// WebShieldApp/Source/Views/ExtensionCheck/EnableExtensionsSheet.swift
import SwiftUI

struct EnableExtensionsSheet: View {
    let missingExtensions: [String]

    var body: some View {
        NavigationStack {
            VStack(spacing: 20) {
                // Icon with Apple-like alert styling
                Image(systemName: "exclamationmark.shield.fill")
                    .resizable()
                    .scaledToFit()
                    .frame(width: 80, height: 80)
                    .foregroundColor(.red)
                    .shadow(radius: 4)

                // Title
                Text("Extensions Disabled")
                    .font(.title)
                    .fontWeight(.bold)
                    .foregroundColor(.primary)

                // Missing Extensions List
                VStack(alignment: .leading, spacing: 8) {
                    Text("The following extensions are not enabled:")
                        .font(.headline)
                        .foregroundColor(.secondary)

                    ScrollView {
                        VStack(alignment: .leading) {
                            ForEach(missingExtensions, id: \.self) { ext in
                                Text("• \(ext)")
                                    .font(.body)
                                    .padding(.vertical, 2)
                            }
                        }
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .padding()
                    }
                    .frame(maxWidth: .infinity, minHeight: 100)
                }
                .padding(.horizontal)

                // Instruction Text
                #if os(iOS) || os(visionOS)
                    Text("Please enable them in **Settings → Safari → Extensions**.")
                        .multilineTextAlignment(.center)
                        .padding(.horizontal)
                #elseif os(macOS)
                    Text("Please enable them in **Safari → Settings → Extensions**.")
                        .multilineTextAlignment(.center)
                        .padding(.horizontal)
                #endif

                // Open Settings Button (macOS & iOS)
                //                Button(action: openSafariExtensions) {
                //                    Label("Open Safari Extensions", systemImage: "gear")
                //                        .frame(maxWidth: .infinity)
                //                }
                //                .controlSize(.large)
                //                .buttonStyle(.borderedProminent)
                //                .padding(.horizontal)

                Spacer()
            }
            .padding()
            .navigationTitle("Enable Extensions")
        }
        .frame(minWidth: 400, minHeight: 350)  // Ensuring proper size on macOS
    }

    // Open Safari Extensions
    func openSafariExtensions() {
        #if os(macOS)
            if let url = URL(string: "x-apple.systempreferences:com.apple.Safari-Settings.extension") {
                NSWorkspace.shared.open(url)
            }
        #elseif os(iOS)
            if let url = URL(string: UIApplication.openSettingsURLString) {
                UIApplication.shared.open(url)
            }
        #endif
    }
}

// WebShieldApp/Source/Views/Import/ImportView.swift
import SwiftData
import SwiftUI

class ImportViewState: ObservableObject {
    @Published var urlStrings: [String] = [""]
    @Published var isImporting = false
    @Published var showError = false
    @Published var error: Error?

    func reset() {
        urlStrings = [""]
        isImporting = false
        showError = false
        error = nil
    }
}

struct ImportView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.modelContext) private var modelContext

    //    @State private var urlStrings: [String] = [""]
    //    @State private var isImporting = false
    //    @State private var showError = false
    //    @State private var error: Error?
    @StateObject private var state = ImportViewState()
    @FocusState private var isTextFieldFocused: Bool

    let filterListProcessor = FilterListProcessor()

    var body: some View {
        NavigationStack {
            Form {
                instructionsSection
                urlsInputSection
            }
            .formStyle(.grouped)
            .navigationTitle("Import Filter Lists")
            .toolbar {
                ToolbarItemGroup(placement: .cancellationAction) {
                    cancelButton
                }
                ToolbarItemGroup(placement: .confirmationAction) {
                    importButton
                }
            }
            //            .disabled(state.isImporting)
            .alert("Error", isPresented: $state.showError, presenting: state.error) { error in
                Button("OK") {}
            } message: { error in
                Text(error.localizedDescription)
            }
            // Add this modifier to reset state when view appears
            .onAppear {
                state.reset()
                isTextFieldFocused = true
            }
            //            .onDisappear {
            //                state.reset()
            //            }
        }
    }

    private func urlInputRow(for index: Int) -> some View {
        HStack {
            TextField("Enter URL", text: $state.urlStrings[index])
                .autocorrectionDisabled(true)
                .disabled(state.isImporting)  // Move disabled state here
                .focused($isTextFieldFocused)
                .tint(.accentColor)
            if state.urlStrings.count > 1 {
                removeUrlButton(at: index)
                //                    .disabled(state.isImporting)  // And here
            }
        }
    }

    private var addUrlButton: some View {
        Button {
            state.urlStrings.append("")
        } label: {
            Label("Add URL", systemImage: "plus.circle.fill")
        }
        //        .disabled(state.isImporting)  // And here
    }

    private var cancelButton: some View {
        Button("Cancel") {
            dismiss()
        }
        //        .disabled(state.isImporting)  // And here
    }

    // MARK: - Subviews

    private var instructionsSection: some View {
        Section {
            Text(
                "Enter the URLs of filter lists to import, each on a new line. Ensure the URLs point directly to valid filter list files."
            )
        }
    }

    private var urlsInputSection: some View {
        Section(header: Text("Filter List URLs")) {
            ForEach(state.urlStrings.indices, id: \.self) { index in
                urlInputRow(for: index)
            }
            addUrlButton
        }
    }

    private func removeUrlButton(at index: Int) -> some View {
        Button(role: .destructive) {
            state.urlStrings.remove(at: index)
        } label: {
            Image(systemName: "minus.circle.fill")
        }
        .buttonStyle(.borderless)
        .foregroundColor(.red)
    }

    private var importButton: some View {
        Group {
            if state.isImporting {
                ProgressView()
                    .progressViewStyle(CircularProgressViewStyle())
            } else {
                Button("Import") {
                    Task {
                        await importFilterLists()
                    }
                }
                //                .disabled(state.urlStrings.allSatisfy { $0.isEmpty })
            }
        }
    }

    // MARK: - Import Logic

    private func importFilterLists() async {
        await MainActor.run {
            state.isImporting = true
        }

        let validUrls =
            state.urlStrings
            .map { $0.trimmingCharacters(in: .whitespaces) }
            .compactMap(URL.init(string:))

        guard !validUrls.isEmpty else {
            await MainActor.run {
                state.error = FilterListError.invalidURL
                state.showError = true
                state.isImporting = false
            }
            return
        }

        do {
            for url in validUrls {
                let (data, _) = try await filterListProcessor.downloadFilterList(from: url)
                let content = try parseFilterListData(data)
                let filterList = createFilterList(from: content, url: url)

                modelContext.insert(filterList)
                await WebShieldLogger.shared.logFilterListProcessingStep(
                    "Added new filter list: \(filterList.name)", for: "Import")
            }

            try modelContext.save()

            await MainActor.run {
                state.urlStrings = [""]  // Reset URLs
                state.isImporting = false  // Re-enable inputs
                dismiss()
            }

        } catch {
            await MainActor.run {
                state.error = error
                state.showError = true
                state.isImporting = false
            }
            await WebShieldLogger.shared.logFilterListProcessingStep(
                "Failed to import: \(error.localizedDescription)", for: "Import")
        }
    }

    private func parseFilterListData(_ data: Data) throws -> String {
        guard let content = String(data: data, encoding: .utf8) else {
            throw FilterListError.invalidData
        }
        return content
    }

    private func createFilterList(from content: String, url: URL) -> FilterList {
        var title = url.lastPathComponent
        var version = "0.0.0"
        var description = "Imported filter list"

        var foundTitle = false
        var foundVersion = false
        var foundDescription = false

        // Single pass: split on newlines, trim each line, check prefixes
        for line in content.split(whereSeparator: \.isNewline) {
            let trimmedLine = line.trimmingCharacters(in: .whitespaces)

            // Check each known prefix
            switch true {
            case trimmedLine.hasPrefix("! Title:"):
                title =
                    trimmedLine
                    .dropFirst("! Title:".count)
                    .trimmingCharacters(in: .whitespaces)
                foundTitle = true

            case trimmedLine.hasPrefix("! Version:"):
                version =
                    trimmedLine
                    .dropFirst("! Version:".count)
                    .trimmingCharacters(in: .whitespaces)
                foundVersion = true

            case trimmedLine.hasPrefix("! Description:"):
                description =
                    trimmedLine
                    .dropFirst("! Description:".count)
                    .trimmingCharacters(in: .whitespaces)
                foundDescription = true

            default:
                break
            }

            // Early exit once we've found all fields
            if foundTitle && foundVersion && foundDescription {
                break
            }
        }

        // Construct and return the FilterList
        return FilterList(
            name: title,
            version: version,
            desc: description,
            category: .custom,
            isEnabled: true,
            downloadUrl: url.absoluteString,
            downloaded: false
        )
    }

    private func resetUrlStrings() {
        DispatchQueue.main.async {
            state.urlStrings = [""]
        }
    }
}

// WebShieldApp/Source/Views/Logs/LogsView.swift
import SwiftUI

struct LogsView: View {
    @Environment(\.dismiss) private var dismiss
    @State private var logEntries: [String] = []

    var body: some View {
        NavigationStack {
            VStack {
                if logEntries.isEmpty {
                    emptyStateView
                } else {
                    logsContentView
                }
            }
            .padding()
            .navigationTitle("Logs")
            .toolbar {
                ToolbarItem(placement: .automatic) {
                    Button("Done") { dismiss() }
                }
                ToolbarItem(placement: .automatic) {
                    Button(action: copyLogs) {
                        Label("Copy Logs", systemImage: "doc.on.doc")
                    }
                }
                ToolbarItem(placement: .automatic) {
                    Button(action: {
                        Task {
                            await clearLogs()
                        }
                    }) {
                        Label("Clear Logs", systemImage: "trash")
                    }
                }

            }
        }
        .onAppear {
            Task {
                // Fetch logs from the actor
                self.logEntries = await WebShieldLogger.shared.allLogs()
            }
        }
    }

    private var emptyStateView: some View {
        VStack {
            Spacer()
            Text("No Logs Yet")
                .font(.body)
                .foregroundStyle(.secondary)
            Spacer()
        }
        .multilineTextAlignment(.center)
    }

    private var logsContentView: some View {
        ScrollView {
            Text(logEntries.joined(separator: "\n"))
                .font(.system(.body, design: .monospaced))
                .textSelection(.enabled)
                .padding()
        }
    }

    private func copyLogs() {
        let logsText = logEntries.joined(separator: "\n")
        #if os(macOS)
            NSPasteboard.general.clearContents()
            NSPasteboard.general.setString(logsText, forType: .string)
        #else
            UIPasteboard.general.string = logsText
        #endif
    }

    private func clearLogs() async {
        await WebShieldLogger.shared.clearLogs()
        logEntries = await WebShieldLogger.shared.allLogs()
    }
}

// WebShieldApp/Source/Views/Settings/SettingsView.swift
import SwiftData
import SwiftUI

struct SettingsView: View {
    @Environment(\.modelContext) private var modelContext
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject var dataManager: DataManager

    var body: some View {
        NavigationStack {
            SettingsForm()
                .navigationTitle("Settings")
                .toolbar {
                    ToolbarItem(placement: .automatic) {
                        Button("Done") {
                            dismiss()
                        }
                        .buttonStyle(.automatic)
                    }
                }
        }
    }
}

// MARK: - Settings Form
struct SettingsForm: View {
    @EnvironmentObject var dataManager: DataManager

    var body: some View {
        Form {
            developerSection()
        }
        .formStyle(.grouped)  // Grouped style is native on iOS/macOS
    }

    // MARK: - Developer Section
    private func developerSection() -> some View {
        Section(header: Text("Developer").font(.headline)) {
            Button(role: .destructive) {
                Task {
                    await dataManager.resetModel()
                }
            } label: {
                Label("Reset Model", systemImage: "arrow.counterclockwise.circle.fill")
            }
            .accessibilityLabel("Reset the application model")
        }
    }
}

// WebShieldApp/Source/Views/Shared/PulsatingCircleButton.swift
import Foundation
import SwiftData
import SwiftUI

struct PulsatingCircleButton: View {

    enum ButtonState {
        case upToDate
        case needsUpdate
        case notEnabled
    }

    enum FilterState {
        case needsDownload  // Red
        case needsUpdate  // Orange
        case downloaded  // Green
    }

    @State private var isPulsating = false
    @Query(sort: \FilterList.order, order: .forward) private var filterLists: [FilterList]

    var body: some View {
        VStack {
            // Pulsating Circle
            ZStack {
                Circle()
                    .fill(colorForState(currentFilterState()))
                    .frame(width: 4, height: 4)
                    .scaleEffect(isPulsating ? 1.2 : 1.0)
                    .animation(
                        .easeInOut(duration: 1)
                            .repeatForever(autoreverses: true),
                        value: isPulsating
                    )
                    .onAppear {
                        isPulsating = true
                    }

                Circle()
                    .stroke(
                        colorForState(currentFilterState()).opacity(0.6),
                        lineWidth: 8
                    )
                    .frame(width: 2, height: 2)
                    .scaleEffect(isPulsating ? 1.4 : 1.0)
                    .opacity(0.5)
                    .animation(
                        .easeInOut(duration: 1)
                            .repeatForever(autoreverses: true),
                        value: isPulsating
                    )
                    .onAppear {
                        isPulsating = true
                    }
            }
        }
    }

    // MARK: - Helper Functions

    private func colorForState(_ state: FilterState) -> Color {
        switch state {
        case .needsDownload:
            return .red
        case .needsUpdate:
            return .orange
        case .downloaded:
            return .green
        }
    }

    private func currentFilterState() -> FilterState {
        // Determine the state based on the filter lists
        let oneToggledNotDownloaded = filterLists.contains { $0.isEnabled && !$0.downloaded }
        let oneDownloadedNotToggled = filterLists.contains { !$0.isEnabled && $0.downloaded }
        let allDownloaded = filterLists.allSatisfy { $0.downloaded }
        let noneDownloaded = filterLists.allSatisfy { !$0.downloaded }

        if noneDownloaded {
            return .needsDownload  // Red
        } else if oneToggledNotDownloaded || oneDownloadedNotToggled {
            return .needsUpdate  // Orange
        } else if allDownloaded {
            return .downloaded  // Green
        } else {
            return .downloaded  // Default to green
        }
        
        // TODO
        //        let hasPerformedRefresh = AppSettings.shared.hasPerformedInitialRefresh
        //        let lastRefreshedEnabledFilters = AppSettings.shared.lastRefreshedEnabledFilters
        //        let currentEnabledFilters =
        //            filterLists
        //            .filter { $0.isEnabled }
        //            .map { $0.id }
        //            .reduce(into: Set<String>()) { $0.insert($1) }
        //        let anyListDownloaded = filterLists.contains(where: { $0.downloaded })
        //        let anyListEnabled = filterLists.contains(where: { $0.isEnabled })
        //        let anyEnabledListNeedsDownload = filterLists.contains(where: { $0.isEnabled && !$0.downloaded })
        //        let anyEnabledListNeedsRefresh = filterLists.contains(where: { $0.isEnabled && $0.needsRefresh })
        //
        //        // 1. RED: If no lists are downloaded, none are enabled, OR an initial refresh has never happened
        //        if !anyListDownloaded || !anyListEnabled || !hasPerformedRefresh {
        //            return .needsDownload
        //        }
        //
        //        // 2. ORANGE: Needs Update if:
        //        //    - Any enabled list needs downloading OR
        //        //    - Any enabled list needs a refresh OR
        //        //    - The set of currently enabled filters is different from the last refreshed set
        //        if anyEnabledListNeedsDownload || anyEnabledListNeedsRefresh
        //            || currentEnabledFilters != lastRefreshedEnabledFilters
        //        {
        //            return .needsUpdate
        //        }
        //
        //        // 3. GREEN: If all enabled lists are downloaded, none need a refresh, and the enabled filter configuration hasn't changed since the last refresh.
        //        return .downloaded
    }
}

// WebShieldApp/Source/Views/Sidebar/SidebarView.swift
import SwiftData
import SwiftUI

struct SidebarView: View {
    @Binding var selectedCategory: FilterListCategory?

    var body: some View {
        List(selection: $selectedCategory) {
            Section(header: Text("Categories")) {
                let categories: [FilterListCategory] = [
                    .all, .ads, .privacy, .security, .multipurpose, .cookies, .social, .annoyances, .regional,
                    .experimental, .custom,
                ]
                ForEach(categories, id: \.self) { category in
                    NavigationLink(value: category) {
                        Label(
                            category.rawValue,
                            systemImage: category.systemImage
                        )
                    }
                }
            }
        }
        .navigationTitle("WebShield")
    }

}

// WebShieldCookies/Source/ContentBlockerRequestHandler.swift
import Foundation
import os

private let logger = Logger(
    subsystem: "dev.arjuna.WebShield.DeclarativeBlockList-Cookies", category: "ContentBlockerRequestHandler")
private let specificList = "cookies.json"

final class ContentBlockerRequestHandler: NSObject, NSExtensionRequestHandling {
    func beginRequest(with context: NSExtensionContext) {
        let requiredPart = "group.dev.arjuna.WebShield"

        logger.log("Content Blocker logging...")

        guard
            let containerURL = FileManager.default.containerURL(
                forSecurityApplicationGroupIdentifier: requiredPart)
        else {
            logger.log(
                "Error: Could not get container URL for group \(requiredPart, privacy: .public)")
            context.completeRequest(returningItems: nil, completionHandler: nil)
            return
        }

        logger.log("Successfully got container URL for group \(requiredPart, privacy: .public)")

        let blockerlistURL = containerURL.appendingPathComponent(
            "\(specificList)")

        guard FileManager.default.fileExists(atPath: blockerlistURL.path) else {
            logger.log("Content Blocker Error: \(specificList) does not exist")
            context.completeRequest(returningItems: nil, completionHandler: nil)
            return
        }

        logger.log("\(specificList) exists")

        if let attachment = NSItemProvider(contentsOf: blockerlistURL) {
            logger.log("Sending attachment")
            let item = NSExtensionItem()
            item.attachments = [attachment]
            context.completeRequest(
                returningItems: [item], completionHandler: nil)
            logger.log("Completed request")
        } else {
            logger.log(
                "Error: Could not create NSItemProvider for \(blockerlistURL)")
            context.completeRequest(returningItems: nil, completionHandler: nil)
        }

    }
}

// WebShieldCustom/Source/ContentBlockerRequestHandler.swift
import Foundation
import os

private let logger = Logger(
    subsystem: "dev.arjuna.WebShield.DeclarativeBlockList-Custom", category: "ContentBlockerRequestHandler")
private let specificList = "custom.json"

final class ContentBlockerRequestHandler: NSObject, NSExtensionRequestHandling {
    func beginRequest(with context: NSExtensionContext) {
        let requiredPart = "group.dev.arjuna.WebShield"

        logger.log("Content Blocker logging...")

        guard
            let containerURL = FileManager.default.containerURL(
                forSecurityApplicationGroupIdentifier: requiredPart)
        else {
            logger.log(
                "Error: Could not get container URL for group \(requiredPart, privacy: .public)")
            context.completeRequest(returningItems: nil, completionHandler: nil)
            return
        }

        logger.log("Successfully got container URL for group \(requiredPart, privacy: .public)")

        let blockerlistURL = containerURL.appendingPathComponent(
            "\(specificList)")

        guard FileManager.default.fileExists(atPath: blockerlistURL.path) else {
            logger.log("Content Blocker Error: \(specificList) does not exist")
            context.completeRequest(returningItems: nil, completionHandler: nil)
            return
        }

        logger.log("\(specificList) exists")

        if let attachment = NSItemProvider(contentsOf: blockerlistURL) {
            logger.log("Sending attachment")
            let item = NSExtensionItem()
            item.attachments = [attachment]
            context.completeRequest(
                returningItems: [item], completionHandler: nil)
            logger.log("Completed request")
        } else {
            logger.log(
                "Error: Could not create NSItemProvider for \(blockerlistURL)")
            context.completeRequest(returningItems: nil, completionHandler: nil)
        }

    }
}

// WebShieldExperimental/Source/ContentBlockerRequestHandler.swift
import Foundation
import os

private let logger = Logger(
    subsystem: "dev.arjuna.WebShield.DeclarativeBlockList-Experimental", category: "ContentBlockerRequestHandler")
private let specificList = "experimental.json"

final class ContentBlockerRequestHandler: NSObject, NSExtensionRequestHandling {
    func beginRequest(with context: NSExtensionContext) {
        let requiredPart = "group.dev.arjuna.WebShield"
        
        logger.log("Content Blocker logging...")
        
        guard
            let containerURL = FileManager.default.containerURL(
                forSecurityApplicationGroupIdentifier: requiredPart)
        else {
            logger.log(
                "Error: Could not get container URL for group \(requiredPart, privacy: .public)")
            context.completeRequest(returningItems: nil, completionHandler: nil)
            return
        }
        
        logger.log("Successfully got container URL for group \(requiredPart, privacy: .public)")
        
        let blockerlistURL = containerURL.appendingPathComponent(
            "\(specificList)")
        
        guard FileManager.default.fileExists(atPath: blockerlistURL.path) else {
            logger.log("Content Blocker Error: \(specificList) does not exist")
            context.completeRequest(returningItems: nil, completionHandler: nil)
            return
        }
        
        logger.log("\(specificList) exists")
        
        if let attachment = NSItemProvider(contentsOf: blockerlistURL) {
            logger.log("Sending attachment")
            let item = NSExtensionItem()
            item.attachments = [attachment]
            context.completeRequest(
                returningItems: [item], completionHandler: nil)
            logger.log("Completed request")
        } else {
            logger.log(
                "Error: Could not create NSItemProvider for \(blockerlistURL)")
            context.completeRequest(returningItems: nil, completionHandler: nil)
        }
        
    }
}

// WebShieldMultipurpose/Source/ContentBlockerRequestHandler.swift
import Foundation
import os

private let logger = Logger(
    subsystem: "dev.arjuna.WebShield.DeclarativeBlockList-Multipurpose", category: "ContentBlockerRequestHandler")
private let specificList = "multipurpose.json"

final class ContentBlockerRequestHandler: NSObject, NSExtensionRequestHandling {
    func beginRequest(with context: NSExtensionContext) {
        let requiredPart = "group.dev.arjuna.WebShield"

        logger.log("Content Blocker logging...")

        guard
            let containerURL = FileManager.default.containerURL(
                forSecurityApplicationGroupIdentifier: requiredPart)
        else {
            logger.log(
                "Error: Could not get container URL for group \(requiredPart, privacy: .public)")
            context.completeRequest(returningItems: nil, completionHandler: nil)
            return
        }

        logger.log("Successfully got container URL for group \(requiredPart, privacy: .public)")

        let blockerlistURL = containerURL.appendingPathComponent(
            "\(specificList)")

        guard FileManager.default.fileExists(atPath: blockerlistURL.path) else {
            logger.log("Content Blocker Error: \(specificList) does not exist")
            context.completeRequest(returningItems: nil, completionHandler: nil)
            return
        }

        logger.log("\(specificList) exists")

        if let attachment = NSItemProvider(contentsOf: blockerlistURL) {
            logger.log("Sending attachment")
            let item = NSExtensionItem()
            item.attachments = [attachment]
            context.completeRequest(
                returningItems: [item], completionHandler: nil)
            logger.log("Completed request")
        } else {
            logger.log(
                "Error: Could not create NSItemProvider for \(blockerlistURL)")
            context.completeRequest(returningItems: nil, completionHandler: nil)
        }

    }
}

// WebShieldPrivacy/Source/ContentBlockerRequestHandler.swift
import Foundation
import os

private let logger = Logger(
    subsystem: "dev.arjuna.WebShield.DeclarativeBlockList-Privacy", category: "ContentBlockerRequestHandler")

final class ContentBlockerRequestHandler: NSObject, NSExtensionRequestHandling {
    func beginRequest(with context: NSExtensionContext) {
        let requiredPart = "group.dev.arjuna.WebShield"

        logger.log("Content Blocker logging...")

        guard
            let containerURL = FileManager.default.containerURL(
                forSecurityApplicationGroupIdentifier: requiredPart)
        else {
            logger.log(
                "Error: Could not get container URL for group \(requiredPart, privacy: .public)")
            context.completeRequest(returningItems: nil, completionHandler: nil)
            return
        }

        logger.log("Successfully got container URL for group \(requiredPart, privacy: .public)")

        let blockerlistURL = containerURL.appendingPathComponent(
            "privacy.json")

        guard FileManager.default.fileExists(atPath: blockerlistURL.path) else {
            logger.log("Content Blocker Error: privacy.json does not exist")
            context.completeRequest(returningItems: nil, completionHandler: nil)
            return
        }

        logger.log("privacy.json exists")

        if let attachment = NSItemProvider(contentsOf: blockerlistURL) {
            logger.log("Sending attachment")
            let item = NSExtensionItem()
            item.attachments = [attachment]
            context.completeRequest(
                returningItems: [item], completionHandler: nil)
            logger.log("Completed request")
        } else {
            logger.log(
                "Error: Could not create NSItemProvider for \(blockerlistURL)")
            context.completeRequest(returningItems: nil, completionHandler: nil)
        }

    }
}

// WebShieldRegional/Source/ContentBlockerRequestHandler.swift
import Foundation
import os

private let logger = Logger(
    subsystem: "dev.arjuna.WebShield.DeclarativeBlockList-Regional", category: "ContentBlockerRequestHandler")
private let specificList = "regional.json"

final class ContentBlockerRequestHandler: NSObject, NSExtensionRequestHandling {
    func beginRequest(with context: NSExtensionContext) {
        let requiredPart = "group.dev.arjuna.WebShield"
        
        logger.log("Content Blocker logging...")
        
        guard
            let containerURL = FileManager.default.containerURL(
                forSecurityApplicationGroupIdentifier: requiredPart)
        else {
            logger.log(
                "Error: Could not get container URL for group \(requiredPart, privacy: .public)")
            context.completeRequest(returningItems: nil, completionHandler: nil)
            return
        }
        
        logger.log("Successfully got container URL for group \(requiredPart, privacy: .public)")
        
        let blockerlistURL = containerURL.appendingPathComponent(
            "\(specificList)")
        
        guard FileManager.default.fileExists(atPath: blockerlistURL.path) else {
            logger.log("Content Blocker Error: \(specificList) does not exist")
            context.completeRequest(returningItems: nil, completionHandler: nil)
            return
        }
        
        logger.log("\(specificList) exists")
        
        if let attachment = NSItemProvider(contentsOf: blockerlistURL) {
            logger.log("Sending attachment")
            let item = NSExtensionItem()
            item.attachments = [attachment]
            context.completeRequest(
                returningItems: [item], completionHandler: nil)
            logger.log("Completed request")
        } else {
            logger.log(
                "Error: Could not create NSItemProvider for \(blockerlistURL)")
            context.completeRequest(returningItems: nil, completionHandler: nil)
        }
        
    }
}

// WebShieldSecurity/Source/ContentBlockerRequestHandler.swift
import Foundation
import os

private let logger = Logger(subsystem: "dev.arjuna.WebShield.DeclarativeBlockList-Security", category: "ContentBlockerRequestHandler")
private let specificList = "security.json"

final class ContentBlockerRequestHandler: NSObject, NSExtensionRequestHandling {
    func beginRequest(with context: NSExtensionContext) {
        let requiredPart = "group.dev.arjuna.WebShield"
        
        logger.log("Content Blocker logging...")
        
        guard
            let containerURL = FileManager.default.containerURL(
                forSecurityApplicationGroupIdentifier: requiredPart)
        else {
            logger.log(
                "Error: Could not get container URL for group \(requiredPart, privacy: .public)")
            context.completeRequest(returningItems: nil, completionHandler: nil)
            return
        }
        
        logger.log("Successfully got container URL for group \(requiredPart, privacy: .public)")
        
        let blockerlistURL = containerURL.appendingPathComponent(
            "\(specificList)")
        
        guard FileManager.default.fileExists(atPath: blockerlistURL.path) else {
            logger.log("Content Blocker Error: \(specificList) does not exist")
            context.completeRequest(returningItems: nil, completionHandler: nil)
            return
        }
        
        logger.log("\(specificList) exists")
        
        if let attachment = NSItemProvider(contentsOf: blockerlistURL) {
            logger.log("Sending attachment")
            let item = NSExtensionItem()
            item.attachments = [attachment]
            context.completeRequest(
                returningItems: [item], completionHandler: nil)
            logger.log("Completed request")
        } else {
            logger.log(
                "Error: Could not create NSItemProvider for \(blockerlistURL)")
            context.completeRequest(returningItems: nil, completionHandler: nil)
        }
        
    }
}

// WebShieldSocial/Source/ContentBlockerRequestHandler.swift
import Foundation
import os

private let logger = Logger(
    subsystem: "dev.arjuna.WebShield.DeclarativeBlockList-Social", category: "ContentBlockerRequestHandler")
private let specificList = "social.json"

final class ContentBlockerRequestHandler: NSObject, NSExtensionRequestHandling {
    func beginRequest(with context: NSExtensionContext) {
        let requiredPart = "group.dev.arjuna.WebShield"
        
        logger.log("Content Blocker logging...")
        
        guard
            let containerURL = FileManager.default.containerURL(
                forSecurityApplicationGroupIdentifier: requiredPart)
        else {
            logger.log(
                "Error: Could not get container URL for group \(requiredPart, privacy: .public)")
            context.completeRequest(returningItems: nil, completionHandler: nil)
            return
        }
        
        logger.log("Successfully got container URL for group \(requiredPart, privacy: .public)")
        
        let blockerlistURL = containerURL.appendingPathComponent(
            "\(specificList)")
        
        guard FileManager.default.fileExists(atPath: blockerlistURL.path) else {
            logger.log("Content Blocker Error: \(specificList) does not exist")
            context.completeRequest(returningItems: nil, completionHandler: nil)
            return
        }
        
        logger.log("\(specificList) exists")
        
        if let attachment = NSItemProvider(contentsOf: blockerlistURL) {
            logger.log("Sending attachment")
            let item = NSExtensionItem()
            item.attachments = [attachment]
            context.completeRequest(
                returningItems: [item], completionHandler: nil)
            logger.log("Completed request")
        } else {
            logger.log(
                "Error: Could not create NSItemProvider for \(blockerlistURL)")
            context.completeRequest(returningItems: nil, completionHandler: nil)
        }
        
    }
}

